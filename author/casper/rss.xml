<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>airfer.github.io/</title>
   
   <link>http://airfer.github.io/</link>
   <description>There are some things in this world will never change and some things do change,everything that has a beginning has an end </description>
   <language>en-uk</language>
   <managingEditor> Wang Yukun</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>kubernetes在测试中的应用实践</title>
	  <link>//k8s-practice</link>
	  <author>Wang Yukun</author>
	  <pubDate>2017-08-29T19:28:00+00:00</pubDate>
	  <guid>//k8s-practice</guid>
	  <description><![CDATA[
	     <h4>前言</h4>
<p>在休假之前就想写一写kubernetes在测试中应用的一些事，后来因为各种原因被耽搁了下来。这次趁着休假期间的空闲，把应用方面的东西梳理一下，算做是对之前一段研究东西的总结。</p>

<p>研究kubernetes也有一段时间了，在测试方面的应用我将其归类为三个方面：分别为服务部署、环境搭建、持续集成优化 。其实每个方面都值得写一篇文章进行详细阐述，只是最近变的有些懒，就写个总的概况吧。对这个方向感兴趣的同仁欢迎拍砖，也欢迎大家留言探讨，正餐现在开始。</p>

<h4>服务部署</h4>
<p>服务部署作为k8s最主要的核心功能，在实践中被广泛应用是一件很正常的事情。其实这里讲的服务部署，主要是测试服务的部署，当然这和其他服务的部署没有本质的区别。这样做的目的是充分利用k8s集群的特性为我们服务，保证我们测试服务稳定且高效。目前我们的k8s集群上部署了两个服务，一个是jenkins，一个是镜像生成服务takara。就以takara为例来举例说明吧。</p>

<p>首先介绍一下takara，takara服务是根据用户提供的dockerfile文件生成image镜像，并将镜像推送到本地私有registry，成功后返回生成的镜像信息供后续部署使用。其工作原理如下图所示：
<img src="/images/k8s/takara.jpg" alt="" /></p>

<p>takara作为基础服务存在，如果其出现问题将影响后续所有的部署、构建过程，所以其必须稳定。后续由于多个业务线会使用该服务，为了高效快速的生成镜像减少排队情况的发生，Image 生成器会有多个。</p>

<p>从图中可以看出，HttpServer接受get/post的请求，请求的信息中包含dockerfile的地址信息、所需的依赖文件信息等。关于所依赖的物料数据来源有多种方式，例如使用rsync工具，或者直接从hadoop上获取。HttpServer的作用在于解析请求数据，并将解析后的数据写入任务调度队列，供后续worker使用。</p>

<p>由于worker生产镜像的过程是无状态的，所以可以通过kubernetes的replica set动态调整worker的数目。每一个worker位于一个pod中，由两个container组成，分别为Prepare container和Generate container。</p>

<p>前者用于docker build之前的准备工作，主要是获取dockerfile文件，以及相关的依赖文件，并将获得的文件数据进行持久化存储。当前持久化存储使用的是nfs，目前在测试环境下支持良好，速度较快。后者用于根据获取的dockerfile文件数据，生成image镜像，并将镜像重新命名，打tag后推送到私有的镜像仓库，供后续使用。</p>

<p>由于httpserver的上层是kubernetes的service，所以即使一个httpserver挂掉，也不会影响整体的运行。httpserver的数量以及worker的数量都通过replica set进行控制。可以发现，使用kubernetes进行服务部署的好处在于服务的稳定高效，无状态扩展简单。并不是所有的服务都适合在kubernetes上部署，具体情况需要具体分析。
环境搭建
在测试过程中，环境搭建是一个比较头疼的事情，各种操作系统的版本，各种依赖库，每一次搭建都要重复一遍这个痛苦的过程。那么有没有一种方法可以一劳永逸呢？其实答案就是镜像。我们将各种操作系统的版本以及服务运行所依赖的lib库生成一个镜像，然后将镜像上传到我们的私有registry，每次在使用的时候直接从registry中拖取就可以了。</p>

<p>这样看来是非常简单的事情，那么这和kubernetes有什么关系呢?我们安装docker直接pull不可以吗？其实在实际应用中会发现遇到的问题比刚开始所想的要多的多。那么考虑下面几个方面：
- 如果开发同学想要一个环境，但是没有空闲的机器
- 如果你在本地环境发现某问题，如何让开发快速的定位修复
- 如何和同组的其他同学分享你的测试环境
- 当测试环境很多时，如何有效的管理这些环境
- 当测试环境由于一些因素挂掉时，如何保证稳定可用</p>

<p>通过上述的问题，我们发现要满足上面的几个方面，需要保证以下几点：
- 非初次环境的部署要快速，不能部署一个环境需要半天甚至更长的时间
- 环境需要有独立的ip，可以通过ssh访问，便于开发定位问题
- 当环境很多时，需要有一个列表或者table列出环境与ip的对应关系，方便查找
- 当环境因某些原因挂掉时，可以自行重启恢复，重启后数据不丢失
目前部门内部试用的环境部署方案如下图所示：
<img src="/images/k8s/ssh.jpg" alt="" />
从图中可以看出，整体的结构比较简单，其实环境部署的重点在于镜像制作。用户通过ssh登录到中控机，然后在中控机上通过ssh免密码登录所需服务。但是这里需要对以下几点进行说明：
- 由于集群内部中pod的ip为weave overlay网段私有ip地址，所以在公司内网中是无法直接访问。为了解决这个问题，一种方式是将镜像中的sshd服务通过service开放出来，这样通过访问service可以访问sshd服务，但是这种方式存在一些问题，比如在内网中存在external ip无法获取的情况
- 另一种方式，将kubernetes集群中的一个node作为中控节点，通过在中控节点访问kubernetes内部的pod，目前部门内部采用的是这种方式。这种方式相比第一种方法，比较简单不需要配置service，同时也起到了一定的安全保护作用（只可从中控机访问）
- 每个需要启动的环境镜像，都包含了中控机的ssh公钥信息，这样可以做到免密码登录
- 至于查看环境与ip的对应关系，通过kubernetes的dashboard或者在master节点上查看都可以，不过推荐dashboard</p>

<h4>持续集成优化</h4>
<p>持续集成一直是测试关注的重点，在持续集成的实践中，我们也碰到了一些问题。比如，我们需要选择具体在某个jenkins slave node中执行我们的程序，由于程序的执行对操作系统以及相关的依赖库都有要求，所以在运行jenkins任务之前，我们必须保证slave节点已经配置了任务要求所有的要素。</p>

<p>每新增一个slave节点，上述的环境配置都需要重新配置，很耗费时间。同时如果我们的slave节点挂掉了，我们需要去重新启动这个节点；如果这个节点已经下线，那么就需要重新申请一个节点，或者将该任务的执行节点重新迁移到新的节点。</p>

<p>当任务不多，并且节点变动不是很频繁时，这个需求并不是很强烈。但是当支持的业务线众多，各服务依赖的操作系统以及相关库差异性很大时，基于容器的持续集成就变得优势巨大。每个业务线都可以根据自己的需求定制自己的镜像，持续部署时依赖自己的镜像就可以了。</p>

<p>举个例子，假设有5台slave机子都安装了某依赖库，后来由于服务升级，该依赖库也需要进行升级。如果按照传统的方法，需要分别到这5台机子上进行升级，而如果使用镜像，只需要重新生成镜像即可。</p>

<p>使用kubernetes集群进行持续集成最大的优点就是解决了环境依赖问题，最终这个任务究竟在哪个node，哪个pod中运行，根本无需担心。目前基于kubernetes集群的持续集成有两个方式：
一种是直接在master节点上按照pipeline的stage执行程序，程序直接在master节点上执行，和服务部署相同，程序运行结束，pod就终止被删除。
另一种方式，是利用jenkins的kubernetes插件，关于其使用说明github中的文档已经写的很清楚了，就不再赘述了。</p>

<p>关于pipeline的使用并不是本篇讨论的重点，后续@宋大神会专门写一篇文章介绍。</p>

<p>这里以目前的竞价服务的pipeline进行简要的说明。对于竞价服务，和其他服务一样，我们需要一个完整的持续集成体系。在这个持续集成的pipeline中，包含代码静态检测、分布式功能性测试、增量式性能测、手工功能性测试，示意图如下所示：
<img src="/images/k8s/pipeline.jpg" alt="" />
从图中可以看到代码的静态检测用的cpplint以及infer，后续会写一个这两个工具的对比分析；分布式功能性测试除了完成全部的自动化case回归之外，还包括代码的覆盖率统计，用的是gcov；增量式压测用的是部门内部已存在的压测工具端；手工功能测试，使用第二部分的环境进行测试即可。</p>

<p>这里重点说一下增量式压测，压测的目的是检查程序运行的稳定性以及是否存在内存泄露等问题。目前的压测环境用的线上拷贝的全量数据，而压测端用的是从线上截取的部分数据，比如从线上截取20000条。这样就存在一个问题，由于压测端的数据并不具有特异性，无法重点覆盖新增加的功能。考虑一种极端的情况，使用的这20000条数据，得到是同样的样式数据，这样就无法做到覆盖尽可能多的分支。</p>

<p>而分布式回归测试中，自动化case都是具有特异性的，就是为了验证某项功能，那么可不可以将分布式回归的case经过一些修改用于增量式压测呢？其实这个方案是可行的，在休假之前，我已经在物料库测试中进行了验证。假设在物料库服务中的新增代码中存在内存泄露，那么某个自动化case恰好覆盖这个代码分支，那么反复运行该case，内存泄露的情况从kubernetes的node节点中是可以明显查看到的。</p>

<p>由于heapster以及grafana的存在，使得监控pod以及报警变得更加简单，关于其实现机制有兴趣的同学可以去github中查看，下面的例子是当时测试过程中的截图，如下所示：
<img src="/images/k8s/material1.jpg" alt="" />
图一
<img src="/images/k8s/material2.jpg" alt="" />
图二
其实并不是需要运行几个小时甚至一天才能查看到内存是否泄漏，从上面的两个图可以看到即使很短的时间，或许只要几分钟我们也可以看到内存持续增长的趋势。</p>

<h4>后记</h4>
<p>这篇的内容其实是对之前我所做工作的一个梳理，虽然休假之前就想写一写，但是感到头疼，因为涉及的点太多，感觉无从下手。本篇也只是写了一个概览，有很多细节并未提及，希望本篇能给还在这条路上探索的同学一点启发。</p>

<p>很多时候我一直在想提高测试生产力的方法，其实到最后可归为两类，一类是测试技术能力的提升，比如本篇所提及的；另一类则是测试策略。之前写过一些总结类的文章，基本都会涵盖一些测试策略、测试方法。测试的策略与方法并非一成不变的，好的测试工程师应该可以根据业务的需求，定制合适的测试方案。</p>

<p>本篇就到这吧，最后欢迎关注我们的微信公众号，铸盾师~~</p>

	  ]]></description>
	</item>

	<item>
	  <title>基于Ansible && Docker的分布式系统(下)</title>
	  <link>//ansible-docker-2</link>
	  <author>Wang Yukun</author>
	  <pubDate>2017-06-28T16:28:00+00:00</pubDate>
	  <guid>//ansible-docker-2</guid>
	  <description><![CDATA[
	     <h4>前言：</h4>
<p>在上一篇中，我们主要从Poster入手，然后讲述了为何进行这样的技术选型，分别从docker和ansible两个方面来阐述了原因，本篇的重点在于分析集成于镜像中的Unicorn工程，以及playbook脚本的编写。</p>

<h4>一、Unicorn工程</h4>
<p>之所以叫Unicorn这个名称，是因为在整个系统的构建，其扮演者最重要的角色。Unicorn工程的目录结构如下图所示：</p>

<p><img src="/images/unicorn/directory.jpg" alt="" /></p>

<p>该工程主要分成5个部分，每个模块仅从其字面意思应该就可以知道大概了，这里简单的说一下</p>

<ul>
  <li>APP   ：这个应用的主目录，主要的功能就是启动worker，接收任务，执行，写入数据</li>
  <li>Conf  : 这个目录下主要放置系统相关的配置文件，其可配置的内容包括broker队列的相关信息，任务类型信息，Hook脚本配置信息，结果输出类型信息等</li>
  <li>Lib   ：该目录主要用于存放共有调用库，目前主要放置三类，一类为broker driver相关库，比如结果写入Mongodb，或者写入Mysql，或者写入文件。第二类为配置文件解析库，用于解析配置文件</li>
  <li>Script: 该目录下主要放置shell脚本和python脚本，供主程序调用</li>
  <li>Log   : 主要放置运行过程中的日志文件</li>
</ul>

<p>该工程的处理流程如下所示：</p>

<p><img src="/images/unicorn/flow.jpg" alt="" /></p>

<p>将该流程可以简单描述为 加载并解析配置文件 –&gt; 获取broker队列等相关信息 –&gt; 启动worker –&gt; 执行任务  –&gt; 结果数据处理。</p>

<p>其中需要对Script模块进行解释一下，这个模块存在的目的在于worker执行之前，以及执行完写入数据之前对数据进行一些必要的操作，包括清除脏数据，筛出符合条件的数据等。由于采用的是插件话设计，在APP主程序不需要变动的情况下，只需要变动conf文件，以及添加script脚本就可以完成上述操作。这给后续一些数据预处理操作提供了接口。</p>

<h4>二、Ansible的应用</h4>
<p>这个版本区别于上一个版本的地方主要在于Ansible的使用。用一句话概况的话，Ansible使得整个部署更可控，更加规范化。
之前的所有操作，包括物料数据同步、用例case同步、docker管理全部都是通过shell脚本来完成的，这就造成了整个系统和业务的耦合度很高。如果通过Ansible的Playbook脚本的话，将各个部分拆成独立的模块，然后不同的业务分别调用共用的模块，可以很轻松的做到一套服务一套脚本。playbook的处理流程如下所示：</p>

<p><img src="/images/unicorn/flow2.jpg" alt="" /></p>

<p>该流程概况的已经非常清楚了，就不多说了。关于如何使用Ansible来启动docker，其实主要是使用Ansible的docker-image和docker-container模块，下面是playbook脚本中关于启动容器的代码示例：</p>

<p><img src="/images/unicorn/code.jpg" alt="" /></p>

<h4>三、结语</h4>
<p>本篇主要讲述了整个工程的处理流程。原理差不多也就这样了，如果是第一次接触可以查看之前发的第二版分布式系统的相关介绍。很多事情都在发生变化，当前这个版本也有很多需要优化的地方，比如执行节点的调度、容错处理等内容，本篇都没有涉及到。</p>

<p>当分布式遇到容器编排，其实现的方式又存在很大的差别，很多已经成熟的东西我们直接拿来用就好，通过k8s来实现上述的分布式会有更大的优势，特别是运行实例动态调度变化上。技术总是日新月异的变化，我们要做的就是紧跟发展的趋势，别被甩下车。</p>

<p>最后欢迎关注我们的微信公众号”铸盾师”</p>


	  ]]></description>
	</item>

	<item>
	  <title>k8s实践日记之安装篇</title>
	  <link>//k8s-practic-install</link>
	  <author>Wang Yukun</author>
	  <pubDate>2017-05-22T17:45:00+00:00</pubDate>
	  <guid>//k8s-practic-install</guid>
	  <description><![CDATA[
	     <p>其实很早就想深入了解一下容器编排工具，但是由于各种各样的事情，被耽搁了很久。最近就抽时间认真学习了一下kubernets（K8S）,虽然对其原理还未深入的了解，但是从初步掌握的情况来看，真的是一个非常牛的框架，本系列就先从安装篇开始（Centos7下）。</p>

<h4>关于标准安装方式</h4>
<p>其实就是使用kubeadm进行安装，k8s的核心组件全部容器化
https://kubernetes.io/docs/getting-started-guides/kubeadm/
安装之前，需要注意的地方：
- 限制条件，在官方文档中放在最后了，就是Limitations部分，先进行着部分的配置
- 修改/etc/hosts文件，添加本机非lo地址和所对应的名称</p>

<h4>安装过程中存在的问题</h4>
<p>安装过程中存在很多问题，一些比较简单的，稍微查找下资料就可以解决，但是有些却要费一些功夫。除了官方提供的安装教程，网上也有很多网友自发编写的，比如下方的安装教程2.
安装教程2：
http://blog.frognew.com/2017/04/kubeadm-install-kubernetes-1.6.html
在安装教程2中介绍的已经很详细了，一般情况下按照教程安装就可以。
但有以下两点需要说明以下：</p>

<p>1、节点网络选择。
关于pod之间网络的选择，我自己选择的是weave，当然是用flannel也可以。说一下我是用weave遇到的问题。目前我使用的k8s 1.6以上版本，所以选择weave网络的时候，也应该选择对应的版本，进行安装。很多网络的教程用的还是k8s 1.5版本，所以切不可照搬。</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell">1.5版本：  
kubectl apply -f https://git.io/weave-kube
1.6版本：  
kubectl apply -f https://git.io/weave-kube-1.6</code></pre></figure>

<p>选择错误的话，kubedns启动存在问题</p>

<p>2、出现的错误信息。
正常启动后，kubedns容器中错误提示如下：
reflector.go:199] k8s.io/dns/vendor/k8s.io/client-go/tools/cache/reflector.go:94: Failed to list *v1.Endpoints: Get https://10.0.0.1:443/api/v1/endpoints?resourceVersion=0: dial tcp 10.0.0.1:443: getsockopt: no route to host</p>

<p>通过查看网友关于此类问题的描述，初步定位于iptables的问题，通过查看iptables可以看到关于网关端口转发被禁，不知道什么原因导致，如果单条记录删除，k8s可自行恢复。初步修复无果。后来听网友推荐，使用清空iptables链，启动正常</p>

<p>解决方案地址：
https://github.com/kubernetes/kubernetes/issues/44750</p>

<h4>最官方Demo实例安装错误</h4>
<p>节点加入成功后，运行demo示例提示namespace错误</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell">运行的命令如下：
kubectl create namespace sock-shop
kubectl apply -n sock-shop -f <span class="s2">"https://github.com/microservices-demo/microservices-demo/blob/master/deploy/kubernetes/complete-demo.yaml?raw=true"</span>

修改为：
kubectl delete namespace sock-shop
kubectl delete -n sock-shop -f <span class="s2">"https://github.com/microservices-demo/microservices-demo/blob/master/deploy/kubernetes/complete-demo.yaml?raw=true"</span>
kubectl create -f <span class="s2">"https://github.com/microservices-demo/microservices-demo/blob/master/deploy/kubernetes/complete-demo.yaml?raw=true"</span></code></pre></figure>

<p>有关此问题的解决方案链接
https://github.com/microservices-demo/microservices-demo/pull/702
https://github.com/kubernetes/kubernetes.github.io/issues/3214</p>

<h4>安装Heapster 、Influxdb、Garafana</h4>
<p>参考文章：
http://www.jianshu.com/p/60069089c981
需要注意的地方：
- 重新修改端口映射，可以使用外部ip访问
- 添加external ip字段，否则无法访问</p>

<p>英文权威指南：
https://github.com/kubernetes/heapster/blob/master/docs/influxdb.md</p>

<h4>监控部署异常排查</h4>
<p>Heapster的错误日志如下：
E0519 07:06:59.731558       1 reflector.go:203] k8s.io/heapster/metrics/processors/namespace_based_enricher.go:84: Failed to list *api.Namespace: the server does not allow access to the requested resource (get namespaces)</p>

<p>E0519 07:07:00.050170       1 reflector.go:203] k8s.io/heapster/metrics/sources/kubelet/kubelet.go:342: Failed to list *api.Node: the server does not allow access to the requested resource (get nodes)</p>

<p>原因定位：初步判断是RABC角色机制导致的这个问题
错误的解决办法：</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell">kubectl create clusterrolebinding add-on-cluster-admin <span class="se">\</span>
    --clusterrole<span class="o">=</span>cluster-admin <span class="se">\</span>
    --serviceaccount<span class="o">=</span>kube-system:default</code></pre></figure>

<p>关于此问题的英文解决方案说明：
https://github.com/kubernetes/kubeadm/issues/248</p>

<h4>结束语</h4>
<p>本篇文章是kubernets容器编排系列的第一篇文章，主要介绍了安装过程中踩的一些坑，以及一些注意事项。每个人在安装过程中可能遇到的问题都不太一样，遇到问题并不可怕，沉下心来，分析错误的原因，总会找到解决方法。</p>


	  ]]></description>
	</item>

	<item>
	  <title>基于Ansible && Docker的分布式系统(上)</title>
	  <link>//ansible-docker-1</link>
	  <author>Wang Yukun</author>
	  <pubDate>2017-03-25T17:19:00+00:00</pubDate>
	  <guid>//ansible-docker-1</guid>
	  <description><![CDATA[
	     <p>从最初的V1.0的分布式用例框架，到现在已经发展到V3.0版本，功能已经越来越完善，执行效率相比第一版也有了质的提升。遇见不同，其实就是见证全新的自己，我相信我们在这条道路上会越走越好。</p>

<h4>Poster</h4>
<p>前一段时间，部门内部举办了一场技术开放日活动，我和组内的宋大神，做了关于第三版通用分布式用例框架的Poster，一些同学对我们所做的很敢兴趣，当时因为时间有限，并且人又很多，许多地方讲述的也不太完善。趁着五一之前的少许空闲，把Poster的内容稍微梳理一下，算是我个人对这段时间的一个总结，对可能感兴趣的同学也会有一些帮助。</p>

<p>poster的内容如下图所示：
<img src="/images/pc_ads_distribution/ansible_docker_framework.jpg" alt="" /></p>

<h4>我们的痛点和目标</h4>

<p>Poster中列出了V1.0版本，和V2.0版本的痛点，这里简要的说一下。运行时间长，以及分布式节点扩展困难，以及case的粒度无法控制，主要对V1.0来说的。关于详细的一些情况，可以查看之前发的文章。</p>

<p>需要人工选择部署的主机，这个是V2.0版本的遇到的，我们设想的流程是提交任务后，框架自主的从主机列表中选择合适的主机，然后去执行任务，这在V3.0版本已经解决了，虽然方法有些简单，但是也算初步解决了问题，后续在进行完善。</p>

<p>我们的目标其实就是打造通用型、高效的用例执行框架，把其作为服务提供给开发人员和测试人员。V2.0版本虽然初步完成了这个目标，但是由于其和业务联系紧密，扩展性较差，这也是开发V3.0版本的一个原因。</p>

<h4>优势在哪？</h4>

<p>V3.0版本的分布式用例执行框架，优势主要体现在三个方面：</p>

<ul>
  <li>
    <p>更简单：
每一个服务Server，都会有自己独立的一份配置。配置之间的修改也互不影响，初次之外，配置的填写和管理，全部集成在部门内部的测试平台中，只要有相对于的修改权限，都可以修改配置，执行任务。整个过程简单明了</p>
  </li>
  <li>
    <p>更智能：
更智能则体现在主机的分布式节点部署上，通过自有的算法动态的选择主机，然后自主部署，省去了人工选择Host的麻烦，可以做到比人本身更出色的分配，调度能力。目前在分布式节点部署调度上，所试用的规则有三条：
a. 在Host主机中资源满足条件的情况下，优先在已经部署过分布式节点的host上执行部署任务
b. 如果是初次部署任务，优先在资源剩余量最大的Host上部署任务
c. 针对所部署的节点数目以及host资源，完美拆分后部署（目前还不支持）</p>
  </li>
</ul>

<p>对于规则a的规定，其实是和业务紧密联系的。由于我们容器需要加载的文件太大，所以拖取需要加载的文件需要花费大量的时间，所以在host主机资源允许的情况下，尽量在已经部署过节点的主机上部署</p>

<p>和一般分布式框架不同，本分布式用例框架采用异步抢占式的调度策略，关于该抢占策略的实现，主要是借助Celery来完成的。在之前介绍V2.0版本的时候已经做了阐述，这里不细说了。</p>

<ul>
  <li>更高效：
更高效体现在一台主机，可以同时运行多个服务实例，相比于V1.0版本，case的执行效率可以成倍提升。V2.0版本已经实现了这一方法，在V3.0版本中继承了V2.0版本中优势的地方。</li>
</ul>

<h4>Why Ansible ?</h4>

<p>Ansible的好处在poster中已经列出来了，之前我对ansible也不熟悉，但是用过之后发现真的非常方便。由于是Agentless框架，所以无需在被操控的主机上安装客户端。</p>

<p>现在我们做到一套服务，一份配置，说的更明白一点，这份配置就是ansible的 playbook脚本，而动态主机信息的获取也主要是通过Ansible的动态Inventory来实现的。配置信息填写界面如下图所示：</p>

<p>这一点和V2.0版本有显著的不同，在V2.0版本中，任务资源获取、加载、执行，完全是整合在一起。没有使用Ansible来进行任务信息，主机资源信息的收集和管理，这也导致了业务和框架的耦合度太高，迁移到其他业务的成本太大，也是做V3.0的根本原因</p>

<p>在技术分享日的当天，有很多的同学问我，为啥选择ansible而不选择SaltStack等工具呢？其实我没有使用过SaltStack，在网上看到对比说，SaltStack的执行效率要比Ansible高，但是由于我们是测试环境下部署，对于执行效率并没有太高的要求；再者部门内宋大神使用Ansible已经很长时间了，现有的很多服务部署执行，都是基于Ansible来做的，所以在执行工具的选择上就选择了Ansible。除此之外，ansible对docker支持良好，这也是一个非常重要的原因。</p>

<p>所以，是不是选择Ansible还是要具体情况具体分析。</p>

<h4>Why Docker ?</h4>

<p>选择docker的原因，在前几篇的文章中已经分析过了。poster中简单的列了几条，之前由于只在PC业务中使用docker，所以维护一份镜像就够了。现在为了适应不同的业务线，我们做到了一份服务（一个server），一份镜像，根据业务需求进行定制。将构建好的镜像推送的私有的Docker Registry中，需要部署任务的时候从中拉取，方便管理且高效</p>

<p>每一次运行任务，都会重新启用新的容器，由于容器之间不需要相互通信，所以全部都使用bridge模式，运行一次构建一次，运行结束后就删除容器，释放计算机资源，这样真正的做到了任务之间的互相不影响。</p>

<p>只要计算机资源允许，可以在同一主机上运行多个服务实例，这相当于将一台主机当几台来用，不但提高了执行效率，还充分利用了现有的计算机资源。</p>

<p>关于docker在分布式用例系统中的具体应用，如果感兴趣，可以阅读以下之前发的相关文章，关于docker就说到这吧</p>

<h4>后记</h4>

<p>V3.0版本已经解决了很多问题，但是仍有很多问题没有解决，poster中也列出了2点。这都在后续完善的范畴之内。在分享日的当天，有些同学问了我这样一个问题，如果容器之间需要相互通信该怎么办呢？其实在此之前我都没有仔细考虑过这个问题，由于我们的部署在容器中的服务，不需要在容器之间相互通信，其所依赖的其他服务全部都是Mock桩并集成在单个容器中。所以对于容器之间相互通信的解决方案，我想了几个，可能不是很完善，发出来，全当同学们之间交流了</p>

<ul>
  <li>像目前我所做的，如果其依赖的都是Mock桩，那么可以将其集成在单个容器中，这样就绕过了容器之间通信的问题</li>
  <li>如果所依赖的都是真实的服务，如果自己实现容器的调度，可以通过host模式以及端口映射来解决，但是其访问的规则也要在配置文件中写清楚防止混乱</li>
  <li>如果系统是centos7等高版本系统，可以使用一些容器编排工具，包括新版的swarm或者k8s，我自己没有使用编排工具进行过分布式用例系统设计，所以更多的建议我也无法给出了</li>
</ul>

<p>其实本篇只是梳理了一下poster的内容，对一些内容作了进一步阐释，在下篇中会讲述playbook脚本文件实现，以及集成于镜像文件中的unicorn（独角兽）工程。测试，遇见不同，遇见不同的自己。</p>

<p>最后欢迎关注我们的微信公众号”铸盾师”</p>


	  ]]></description>
	</item>

	<item>
	  <title>服务端功能测试小记</title>
	  <link>//summerize-for-server-test</link>
	  <author>Wang Yukun</author>
	  <pubDate>2017-03-25T17:19:00+00:00</pubDate>
	  <guid>//summerize-for-server-test</guid>
	  <description><![CDATA[
	     <h4>前言</h4>
<p>过年回来之后，业务的功能测试渐渐多了起来，我之前一直负责的是PC方面的测试，而现在除了负责PC的业务测试之外，还负责无线业务的测试。骤然间自己所有的时间差不多都被功能测试任务占据了，到2月份末的时候，关于测试任务的排期都排到了4月初。</p>

<p>在这功能测试的狂轰滥炸中，慢慢的对于服务端重服务的功能测试有了更多的体会，趁着周末空闲的时间整理一下，以飨各位读者。</p>

<h4>功能测试就是手工测试?</h4>
<p>早些时候一直有这样的误区，认为功能测试就是手工测试。现在在脉脉的匿名区还有好多同学在感叹，不想做功能测试了，咨询自动化测试好不好学之类的问题。</p>

<p>在某些同学的潜意识里，认为web端的功能测试就是点点点，服务端方面的功能测试也就是手动构造数据，验证逻辑，这虽然比点点点好上一些，但仍没有跳出手工测试的范畴。对于以上的观点，我个人是不认同的，我认为将功能测试完全等同于手动测试是不恰当的，同样将功能测试与自动化测试完全分开来看也是不合理的。</p>

<p>从我自己功能测试的经验来看，将功能测试转变为自动化测试的一部分是效率最高的一种方法。在阐述这个问题之前，我先大致说一下我之前测试的一般情况。当开发提交测试之后，就根据测试单中的信息，手动构造数据，然后启动服务，验证本次提测的业务逻辑，其实这也是最典型的服务端功能测试的流程。这样做的好处就是可以快速的验证本次提测的业务功能，弊端就是当需要构造的数据量太大的时候，时间的成本也会很高。</p>

<p>除此之外，使用手动构造数据进行功能测试，在多次功能回归的情况下，测试人员是崩溃的，因为开发每修改一些代码，你就要把之前的case都过一遍。PC业务线之前就是这样的做法，先进行手工功能测试，后续抽时间在填充相关的测试case。无线业务线恰恰采用了另一个方法，先抽时间将case写完，然后根据提测需要完善相关case。</p>

<p>在两条业务线实验了一段时间发现，无线业务线所采用的方法，也就是将功能测试变为自动化测试的一部分，效率要高很多。特别是由于一些需求变动，或者少量代码修改，需要验证是否影响之前所测功能的时候，效果尤为明显。这个时候我就让开发人员自己去跑一遍自动化case，而我也从重复的功能性结果验证中解放了出来。这个小主题的意义在于，是否能将现有的功能测试，整合进自动化测试中，当然不同的业务的要求也不一定一致，大家根据自己业务的特点，自行评估即可。</p>

<h4>讨论维护自动化case的必要性</h4>
<p>虽然自动化测试有很多的好处，但是维护自动化case确充满了痛苦，甚至有些时候你恨不得从此再也不用它了。让人如此仇恨的原因，每次跑case失败的太多，而且失败的case大部分是很久之前的功能，很多时候你根本就从来没有听说过这个功能，这种情况下去查看与之相关的case为何失败，我相信很多人面对这种情况，心情都不会太好。</p>

<p>通常情况下，你排查了良久，也无法判断为何某些case失败，郁闷的心情可想而知，这个时候你可能会想，如果只是回归当前提测的功能该是多么幸福的一件事。在经历了多次这种事情后，慢慢的也察觉了一些规律，以及排除某些错误case的方法。就像电视上或者生活中没有无缘无故的爱，也没有无缘无故的恨一样，在自动化case的回归的世界中，也没有无缘无故就失败的case，每一个失败的case都有其失败的原因。</p>

<p>当错误的case发生时，需要排查代码的上一个版本中该case是不是失败。一般情况下，上一个版本的case应该都是全部通过的，因为如果case不通过肯定无法上线嘛。这个时候你就对比当前代码的版本和上一个代码版本，看看究竟是修改了那些内容使得case失败了。通过代码文件静态对比，以及运行期间的gdb单步调试，我想找出失败case的原因不是难事。</p>

<p>经历过多次这样的事情后，就看的比较开了，出现失败的case也会慢慢的去分析原因，不用一出现问题就去喊开发。在这里多说一句，测试人员和开发人员应该保持相对的独立性，不要什么都依靠着开发，如果真的需要找开发来解决某些问题，你应该能大致知道问题出错可能的原因在什么地方。</p>

<h4>如何高效的写自动化case</h4>
<p>谈到写自动化case，很多同学就说，这个很简单，按照EXCEL表中或者xmind图中功能测试的用例，把所有的case都写上就好了。当然这个情况下是最理想的，把所有可能的情况都覆盖掉，但是现实情况下，你可能根本没有时间将所有的case全部写完，这个时候你就要在规定的时间内，用最少量的case完成最大的代码覆盖，拒绝重复的case，以及一些非常简单的case。</p>

<p>重复的case这个比较好理解，比如某项功能在某个测试用例中已经验证过一次了，那么就没有必要在其他的case中再验证一遍。那么什么是简单的case呢？说到简单的case，就要提及代码review了，现在很多测试不参加开发的代码review，当然各种原因都有，比如时间紧、任务重啊，或者没有这样的惯例啊等等。</p>

<p>我想说的是，如果有条件，尽量在进行完粗略的主功能验证后，开始进行代码review，代码reivew不但可以让你对所测业务理解加深，提前发现一些代码级的bug，对于编写自动化测试用例也是益处良多。比如代码中，有关于某些字段的验证，再仔细查看代码后，针对性的构造自动化case，没必要根据每一个字段分别构造case，甚至你通过查看代码某部分业务逻辑已经非常清楚了，在时间紧的情况下，可以不添加与之相关的case。</p>

<p>简单的case是建立在你对代码逻辑异常清楚的情况下，判断某业务逻辑非常简单，不值得添加用例进行覆盖的case。恩，比较绕口，但应该不难理解。</p>

<h4>框架的易用性、通用性以及高效执行</h4>
<p>当case添加完成之后，总体回归所有case时，一般为了节省时间会将case分发到多台主机上同步执行。当case的数量巨大时，这种设计思路非常有必要，以目前的无线的自动化case举例，现在差不多接近600个case，如果放在单台机子上跑的话，跑完要1个半到2个小时。</p>

<p>如果分散到三台机子上跑，可能半个小时就跑完了，case数量的不断增加，分布式执行成为必要。关于分布式构建之前已经写过文章分享过，这里就不再过多阐述了，有兴趣的同学可以自己找来看看。</p>

<p>本小节要重点谈的是框架的易用性、通用性和高效执行。易用性很好理解，就是上手非常快，只需要填写少量必须的参数，整个任务就可以跑起来了，想目前一直在使用的第一版基于jenkins的分布式系统，只需要填写本次代码的svn地址或者bin文件，然后根据功能需要在中控机上做少量修改，就可以执行了。因为上手非常容易，所以教开发自己来跑任务也不用花很多时间成本。</p>

<p>我之前设计的第二版分布式系统，解决了易用性和高效执行两个方面，但是在通用性上做的不好，所以到现在就pc业务线在用，甚至我想把无线的分布式迁移过来，也不是几行代码或者几个小时能搞定的。由于现有的框架和业务联系太紧密，导致了扩展性也不好，现在正在开发基于ansible和docker的分布式解决方案。关于这个方案我会在后续的文章中详细的谈，这里就不多说了。特别是在大部门，多业务线的情况下，一个框架的设计要兼顾几个方面，能复用就复用，不要重复的开发，浪费人力物力。</p>

<p>高效执行之前也谈到过了，就是如何在尽可能短的时间内，将程序运行完。第一版的分布式系统虽然利用分布式主机的特点，提高了执行时间，但是还是没有把现有的计算机资源利用起来。第一版的分布式系统，单主机情况下，同一时间只有一个服务实例在运行，而现有的主机资源，可以同时支持3个甚至更多的运行实例，所以第二版分布式系统和第三版就利用docker 容器规避了这个问题。对于一个通用性的工具或者框架，以上三个因素都非常重要，如果不能兼顾的情况下，根据业务需求自行取舍吧。</p>

<h4>结语</h4>
<p>啰啰嗦嗦说了这么多，主要是我自己的功能测试感悟，可能对某些方面的理解有些偏颇，大家不必较真，毕竟对于同样的问题，每个人都有每个人的看法。如果能从文章中感悟一点有益的东西，也不枉费了我周末码字的辛苦。同样欢迎有不同看法的同学留言交流……..</p>


	  ]]></description>
	</item>

	<item>
	  <title>年终总结2016,写在农历鸡年之前</title>
	  <link>//summerize-2016</link>
	  <author>Wang Yukun</author>
	  <pubDate>2017-01-27T10:19:00+00:00</pubDate>
	  <guid>//summerize-2016</guid>
	  <description><![CDATA[
	     <h4>前言：</h4>
<p>一直想抽出时间来把这一年所做的事情总结一下，但是每次开始写的时候又不知道该从何写起，毕竟一年经历了很多的事情。为了不在记述的时候产生跳跃感，我就按照时间线的顺序写吧，如果要先有一个概述的话，那2016算是稳中有升的一年~</p>

<h4>前半年：</h4>
<p>2016年的前半年，主要还是在老东家360中渡过的。那个时候我从360支付平台转到360广告平台也有一段时间了，对广告平台的理解也慢慢的变深，主要负责的是360广告平台的front端的测试。测试的内容起先负责包括广告的展现打点、计费打点、打点信息校验、广告展现兼容性测试等内容，后来也负责了一部分eapi的接口测试、kafka消息队列相关测试等内容。</p>

<p>在测试的过程中对广告平台的理解也逐渐深入，其实这相当于是一个打基础的阶段，毕竟相关业务的测试都是在这个基础之上的。测试的主要方式还是手动人工测试，除了看日志之外，很多功能的测试都是需要去手动完成，例如点睛投放平台相关测试，基本上靠人工，由于投放平台的界面变化较大，做UI自动化成本太高，任务又急，这个时候也只能靠人了。</p>

<p>当时我的leader是萍姐，反正从我转入广告平台后，一直都是萍姐带着我熟悉广告平台的很多东西，萍姐是一个很称职的leader。即使后来我要离开公司，其实对萍姐还是有很多不舍，最后走的时候萍姐对我说的话，我现在也铭记着。<em>其实在工作中遇到对自己有帮助的人都是应该感恩的，毕竟并非每个人有义务对你好，给你指导，在工作中遇到一个好的leader真的是一件很幸福的事情</em>。扯远了，其实除了leader的指导帮助之外，更多的是靠自己去实践和领悟，别人教你的东西始终是别人，想把这些东西转变成自己的，只能靠自己多实践、多想、多问！</p>

<p>我对广告平台认识加深的过程，其实是在测试凤舞项目的时候，由于这个项目牵扯到方方面面，包括广告平台的物料投放、eapi接口、消息队列、searchfront引擎前端、query检索端、index检索生成、material物料库、广告展现、front打点等等。所以当这个项目测试完毕，我对于广告平台的认识也变得更加的深入，所以实践出真知不是没有道理的。但是由于引擎端的代码并不对测试人员开放，所以引擎端的处理逻辑对测试人员是黑盒，这在一定程度上也阻碍了测试人员的进一步深入。</p>

<p>其实前半年在点睛业务团队，也做了很多自动化的东西，包括打点的网页端展示系统、基于Nodejs的轻量级日志监控系统等，原本打算基于ELK技术栈来改进现有的日志监控，由于后来离职了，只对交接的人员大致讲述了下思路。其实到新公司之后，我也了解过我做的这些工具的情况，状况很令人心碎，这些工具无人维护基本上死掉了。我觉得这个状况在各个公司都存在，很多人觉得维护旧的工具还不如直接做个新的，重复的造轮子。后来想到之前的教训，我在现在的公司才更多的强调，开发工具的稳定性以及可维护性。我的目标是即使我离职了，我开发的工具也还可以运行N年。。。</p>

<p>总之,2016前半年更多的收获是在对广告平台的认识和理解，收获的是即使是做手工测试人和人之间的差距也可以很大，收获的是测试工具的根基在于业务，对业务了解不深，为了做工具而做工具得到的只能是失败。在离开360的时候，我自己的目标就是做一名顶尖的功能测试工程师。收获有很多，当然也有很多遗憾，遗憾的是对某些业务的深入程度还不够，比如ESC统计计费，还有就是没有加强自己的开发能力，业务虽然很重要，但是开发能力也很重要，不要顾此失彼。</p>

<h4>后半年：</h4>
<p>从老东家360离开之后，便来到了现在的公司，搜狗。其实之前对搜狗并不是很了解，我影响最深的产品就是搜狗输入法，其他的真不是很清楚，后来面试之前还好好的补了下课。来搜狗也有一定的缘分吧，记得有一次，我现在的leader ZZ,在脉脉上和我随便聊了几句，感觉这个leader挺好的，后来就约了个时间过来聊聊，后来就来了搜狗，哈哈。我在搜狗这边也主要负责的是广告这块，只不过负责的内容对我来说正好是我之前不太了解的，之前在360的时候，负责的是搜索引擎之上的测试，比如广告投放平台；在这边主要是负责搜索引擎本身，主要是广告内容的检索、加载、展现、屏蔽等内容。这恰好是对我缺失的部分进行了一个弥补，毕竟在360，我也接触不到引擎级的代码。</p>

<p>刚开始接手的时候还是有难度，毕竟我之前也没接触过。刚开始最让我吃惊的是，竟然在1个月之后要进行代码串讲，相当于要在1个月的时间对引擎的代码读一遍，然后理出思路，这对刚接手的我绝对是个不小的考验。除了看之前关于引擎的笔记之外，我师傅军哥，还有佳佳，都帮了我很多，毕竟要想在较短的时间内掌握更多的东西，还是要多向前辈们请教，搜狗的同事都很nice，你只要问，同事都会乐于告诉你。</p>

<p>代码串讲之后，也就开始慢慢的接各种业务提测，在测试过程中就会发现，在熟知代码后，测试的逻辑也变的异常清晰。源码面前无秘密，这次我是深刻体会到了。测试也参与开发的代码review，确实让测试快速的成长起来。熟悉了基本的业务后，就可是熟悉各种已经存在的测试工具、系统，我接手的时候这些测试工具都维护的比较好，主要是分布式测试系统，以及压力测试系统。每次测试完功能后，将这两个功能都跑一篇，进一步查漏补缺，有好几次bug就是在查漏补缺的过程中找到的。</p>

<p>我慢慢的体会到了，分布式系统以及压测系统的重要性，后来也慢慢的接手维护的工作。到现在为止，我们每次跑的全量case数据大约在540条左右，所有的提测任务完成后，在一定的时间内就会把case添加到case集中，这形成了一个正向的循环，测试人员也慢慢的从重复的功能性回归中解放出来。现在的分布式测试系统，以及压测系统，开发也会自己去跑，我们现在所做的慢慢由之前的一次性交付向测试服务provider转变。这是一个很好的现象。</p>

<p>到了现阶段的话，除了维护测试工具的稳定性，完善case集之外，更多的是对现有的工具进行改进，提升测试效率，提高生产力。为了缩短分布式系统的执行时间，我们引进了docker，使用docker容器来作为基础单元参与调度，所有case的执行时间由原先的20多分钟缩短到5分钟。与此同时，为了管理docker容器，我们使用了swarm以及shipyard来进行基础容器编排以及拓展，并结合ansible来提升管理的效率。在压力测试中，我们正在整合现有的压测工具，使之平台化、通用化。</p>

<p>除此之外，我们还开发了新版的广告预览平台，开发测试都在使用，其实由一次性交付向持续交付转变，最多的障碍其实是在思维上。不管怎么样，我们都是在不断的改变自己，不断的利用新的技术、方法、思维来提高测试的生产力，这个方向总归是对的。</p>

<p>除了技术方面，如何让别人来分享自己的研究成果也是很重要的一方面，之前都是规定每个人都要进行分享，到后来很多同学觉得这变成了一个负担，分享的质量也有所下滑。分享结束后，如果没有参加分享的人可能只能通过看ppt来大致了解所讲述的内容，所以单纯的讲座效果并不如想象的好。现在部门内成立了技术影响力小组，老大让我负责，其实我有些诚惶诚恐，毕竟我自己的技术也很一般，只希望自己能近最大的努力把这件事情做好。大致弄了一个大纲，后续和leader去对一下，然后慢慢的把这件事做起来。</p>

<h4>结语：</h4>
<p>时间过的真的很快，一转眼2017已经来了。2016年对我来说是成长和收获的一年，希望自己和部门能够在新的一年里越来越好！2017，加油干，撸起50亿！！！</p>

	  ]]></description>
	</item>

	<item>
	  <title>测试总结之述职杂谈</title>
	  <link>//summerize-report</link>
	  <author>Wang Yukun</author>
	  <pubDate>2016-11-26T10:18:00+00:00</pubDate>
	  <guid>//summerize-report</guid>
	  <description><![CDATA[
	     <h4>前言:</h4>

<p>最近一段时间一直在忙着平台开发的一些事情，一直都没有时间梳理和总结这过程中的点滴。下个月要准备述职报告，所以就借着这个机会把测试过程中的一些感受记下来，以飨各位看官。本篇是杂谈，所以不谈具体技术，只谈风月…..</p>

<h4>一、论工具之稳定性压倒一切</h4>

<p>作为一名测试开发工程师，测试工具应该是非常熟悉了，测试工具是测试过程中的好帮手。好的测试工具对于测试人员效率提升以及减少漏测率都有非常大的帮助。测试工具的来源也有很多，有的工具是较为成熟可以直接拿来用的，有的是基于一些开源的项目然后根据自我需求二次开发的，还有一些是对于某些需求特殊定制的等等，那么对于测试工具什么最重要呢？</p>

<p>从标题可以看出我的结论是，稳定性是一个测试工具最核心的需求。当然这并不是说测试工具的执行效率，测试工具的可扩展性以及可维护性不重要，只是相对于这些特征，稳定性才是一个工具必须要保证的特质。</p>

<p>从半年前的入职到现在，搜狗ADTQ测试组给我留下较深印象之一便是持续集成做的非常出色。因为我所在PC组，所以就以PC组举例。现在PC组对于新增的提测单，除了人工的验证新增功能以及样式展示外，其他的全部交给自动化来执行，包括所有case的分布式执行测试、新旧版本的压力测试、新旧版本的对比测试等等。其中令我吃惊的是这些部署在jenkins上的任务，大多是在2014年就已经完成开发，从2014年到现在一直都在稳定的运行，除了进行必要的维护以及case更新之外，这些工具都表现的非常出色。</p>

<p>这些工具大部分是东哥（暂且这么叫吧^^）开发的，主要通过shell脚本来实现，我和东哥也没见过我入职时东哥已经离职了，但这也不妨碍其所做的工具对我们目前工作的帮助。以case的分布式测试为例，其实现分布式也并非用了非常高深的技术，主要是通过jenkins的api以及shell来完成，就这个看似简单其实并不简单的工具支撑着我们每次上线前的500多个case的回归，帮助我们减少漏测的情况。只要case的分布式执行出现问题，比如突然失败几十个，有可能是功能的漏测，也有可能是合并后的代码有误。</p>

<p>这个分布式case的执行工具之所以可以用的现在，其本身程序的稳定性占有很大的比例，如果一个工具每次的运行都不稳定，或者运行的时候时不时的报个错误，出现个exception，你还会信赖它？还会用它吗？</p>

<p>我所希望的工具就是在我需要它的时候，它能够按时完成我交给它的任务，别给我出乱子，这就足够了。我最讨厌的测试工具就是我一边在使用着这个工具，一边忍受其所报的各种错误提示，对于出现的错误我还要调试半天究竟是什么地方出错了。就是这样一件非常简单的要求，又有多少工具能够很好的满足呢，所以我才要特别强调工具稳定性的重要性，我希望即使我以后离开公司，我的工具也可以在仅有必要维护的情况下能够很好的工作。</p>

<p>最近一段时间做了两个内部使用的平台，其中一个就是开发了新的分布式测试系统，改进了原先分布式测试系统的一些缺点。在试运行阶段，修改了各种bug，现在已经上线并取代原有的分布式测试工具。在开发新的分布式测试系统时，我就感觉到要做好一个工具的稳定性真的非常不容易，需要考虑各种可能的情况，比如一些特殊的输入，执行过程中可能出现的异常，还有case执行过程中的一些特殊的依赖等等。</p>

<p>希望新的分布式测试平台能够发扬老一辈分布式测试系统的优点，将稳定性的核心特质保持下去。这里感谢下东哥，在设计新的测试系统时借鉴了很多老平台的优点。</p>

<p>其实当设计平台将稳定性考虑在内时，你就会考虑更多的东西，比如你的系统需要依赖机子A上的某个文件，如果这种依赖关系是硬编码在代码中，那么极有可能出现A机子文件被删除导致获取失败的情况。这种情况下如果是你自己在维护可能还好，如果你已经离职，新入职的员工如何知道你所依赖的这个文件是什么内容，这种依赖关系是否是必须，这些新员工都不清楚。</p>

<p>如果这种依赖关系是可配置的，不管是通过xml还是json或者web界面，并对这种依赖关系进行详细标注，甚至说明所依赖文件的生成方法，那么这种系统的稳定性以及可维护性就要好很多，甚至不需要去读测试工具的代码就能搞定所出现的问题。关于稳定性还有很多的要求，由于我自己也处在学习阶段，所以就先谈到着吧</p>

<h4>二、论旧工具与新工具的前世今生</h4>

<p>旧工具可以理解为早些时候开发的工具，这些旧的工具有些可能还在使用，有些可能因为年久失修已经废弃了。当需要这些测试工具所提供的功能时，是继续使用这些即使有些缺点但是还可以使用的旧工具，还是花费大量时间精力去开发新的工具，我相信很多测试同学都有过这种选择，在综合权衡下，做出自己的选择。</p>

<p>我知道肯定也有一些同学与我的想法一致，旧的工具用着不顺，新的工具开发成本又太高，那么就综合两者，以旧工具为蓝本添加新的功能修复原有工具的缺点。当然这三种选择并没有孰优孰劣，能根据具体的测试需求综合权衡，做出正确的选择就好。比如原有的工具实在是太难用，而这个工具开发有比较简单，那么可以考虑重新开发一套，具体情况具体论，切勿盲目追从。</p>

<p>本节所谈论的主要是第三种情况，对现有旧工具进行改造，要不怎么说是前世今生呢，哈哈。还是拿我自己举例吧，现在组内的一些工具，比如性能对比工具，其实现起来比较复杂，首先便是需要搭建一套测试环境，然后再进行对比分析，现有旧的工具也还可以使用，像上一节所谈的，稳定性很好，但就是有些缺点比如生成的报告不直观、调用入口单一（大多数情况通过jenkins平台直接调用）、出错排查不方便等。</p>

<p>如果综合权衡考虑这几方面的因素，会发现改进原有旧工具的缺点，并添加所需要的功能是效率最高的。由于现在ADTQ组有一个统一的测试平台，整合了测试组常用的工具，所以考虑是否能够将原有的jenkins任务整合进现有的平台当中，使得调用更加方便，结果展示更加人性化，错误排查容易呢？通过查询资料以及对旧平台代码的通读，发现改造是可行的，是可以实现的。</p>

<p>由于现阶段还没有进行改进开发，所以就大致说一下我自己改进的思路吧：
1. 关于任务的执行、查询、终止等操作全部通过python版本的jenkins api来完成；</p>

<ol>
  <li>
    <p>修改原有的jenkins任务脚本，添加结果收集模块，将收集的结果写入到数据库中，mysql或者Mongodb都可以；</p>
  </li>
  <li>
    <p>重新开发前端页面，主界面主要有任务触发、结果查看等功能。</p>
  </li>
</ol>

<p>其实这个思路也并不复杂，实现起来的成本也不是很大，主要的工作在于前端页面设计以及和数据库的交互逻辑，这样的改进方法比起重新开发新的工具要省事省力很多。当然也有其他的方法，比如组内的宋大神（非常NB）就利用异步框架Celery加paramiko来实现对脚本的调用，以代替jenkins的工作。改造的方法多种多样，可爱的同学发挥你的聪明才智吧~</p>

<p>旧工具与新工具并非是势同水火的关系，如果能让旧的工具进一步贡献自己的价值那么何乐而不为呢。可能有的同学会问，既然比较推崇对旧工具进行改造，那么你为何又重新开发新的分布式测试平台呢？</p>

<p>其实在本章节我有说过，做出某项选择必然是要经过充分的权衡考虑的，我这里解释一下，旧的平台主要有几个明显的缺点比较难以克服所以才考虑开发新的平台，其一是执行的粒度无法控制，其二是分布式节点部署非常繁琐极易出错。这两点我开发新平台的主要因素，现有的平台在节点部署方面做的非常出色，通过ansible可实现1分钟内将分布式节点由3个扩展到N（具体多少看ansible的性能）个，而旧的平台要实现这样的改进就非常困难，其成本不亚于开发新的平台，所以才考虑开发新的平台</p>

<p>前段时间开发的广告预览平台也是放弃了旧的平台，开发新的平台。之所以做出这样的选择，并非是对旧的平台改造困难，恰恰相反，由于预览平台的技术含量较低，并且有现成的api接口可供调用来完成图片获取，开发的成本较低，同时为了界面更加的友好所以才重新开发。举了这些例子就是想说明，究竟采取那一种方法是需要根据具体情况具体分析的，不能因为某些炫酷的功能而盲目开发新平台，同时也不能因为开发新平台或者改进旧平台的成本太大就放弃努力，得过且过。其实大家都知道我说的是什么意思，这里不再赘述了</p>

<h4>三、脚踏实地、仰望星空</h4>

<p>温家宝总理说过这样的话：”一个民族有一些关注天空的人，他们才有希望；一个民族只是关心脚下的事情，那是没有未来的”。温家宝总理说这句话时，想表达的是一个国家即需要踏实肯干的人才，也需要有卓越远见，考虑长远的人才。</p>

<p>这句话放在部门内也同样行的通。在当今的社会我们既要做到踏实肯干，同样也需要能跳出当前着眼长远，不要故步自封。如果只是抱着旧的工具方法、旧的流程规章，虽然短期之内并没有大的坏处，但是长久来看，落后是必然的。所以如果有新的想法、新的设计构想、新的技术就要大胆的尝试，虽然不能保证每次尝试都有好的结果，但是如果连努力尝试的想法都没有，一个部门想保持长久的活力也是不可能的。</p>

<p>还是举个例子吧，现在部门内的无线端广告预览只有模拟版本，也就是分辨率可以确定，通过phantomjs来截图。其实都知道如果能实现真机的截图就最好了，考虑很多方面以及testerhome上分享的文章，我们觉得使用stf或许可以完成这样的功能，虽然最后的结果不一定能成，但是尝试又不收费，再说万一要是成了呢。现阶段各种新的技术、新的方法层出不穷，如果能充分利用现有的新技术、新方法，或许可以做到事半功倍。</p>

<h4>四、论错误排查</h4>

<p>之所以把错误排查单独列出来，是因为我觉得错误排查的能力真的非常非常重要。不管是你自己的程序还是测试工具或者测试环境甚至开发的程序，如果出现了问题，应该知道如何去排查。</p>

<p>现在有些测试同学，都没有自己的测试环境，测试和开发共有一套环境，难道测试的地位真的这么低，都不能有一套独立的测试环境。其实有些时候并非是因为测试地位低，而是测试自己不想去维护这套环境，习惯了只要环境出问题就喊开发来解决，并且认为测试的环境理应当由开发来维护，真不知道为何有这样的想法。如果连维护一套测试环境的能力都没有，还谈什么自动化测试。</p>

<p>我始终相信每个错误的产生必然有其产生的原因。如果一个错误出现了，那么在程序以及资源不发生变化的情况下，其重复出现是必然的。之前出现错误会感到困惑和无奈，而现在则慢慢学会了抽丝剥茧，探索错误产生的根本原因，其实错误排查的过程也充满了乐趣。当然并非每次都是这样，我自己就被一个错误折磨了差不多一个星期，其实差不多都快到崩溃的边缘的，所以耐心也很重要。</p>

<p>举个例子吧，在新的分布式测试系统的实现过程中，就出现了这样一个问题，在docker 节点中通过nosetests来执行case时，有一定的概率server主程序会被杀死，重点就是在这一定概率上，因为对于同一个case有时候server运行是正常的，有些时候则直接被kill掉。我反复将相关的shell以及python脚本通读好多遍，都觉得不应该出现这样的问题。就在我差不多快崩溃的时候，才发现原来node节点中部署了一个case收集程序，这个程序在收集case时会杀掉当前的server程序，由于这是一个crontab任务，所以这才导致了server被杀死的概率性。当时找到这个错误的原因时，真的蓝瘦香菇了。。。</p>

<p>再说一个例子吧，通过docker来部署stf服务的时候，所有都部署完毕，但是stf主程序访问就出现错误，但是stf local程序就可以好好的运行。后来也是经过详细的排查才发现由于stf 容器在vmware虚拟机中运行，而其中的ubuntu虚拟机是采用NAT的方式，这导致了docker0在此网络模式下无法与host进行通信，所以导致无法访问。</p>

<p>举得两个例子是我自己错误排查过程中遇到的两个印象较深的错误，但是好在都找到了原因，其实在错误排查的过程中，你对某程序某方法必要要有很深的了解，要不你怎么排查呢？这样反过来也加深了对某些知识的理解，既解决了问题又涨了知识，这或许是对错误排查过程中所遇到困难的补偿吧。测试同学不要一有问题就找开发了，锻炼一下自己的排错能力吧。。。</p>

<h4>五、总结</h4>

<p>差不多也就这样了，到今天入职也半年了，点点滴滴都记在心里，整理整理自己的收获、感受、所学也是对过去自己的一个交代。下面是之前发在论坛上的几篇文章，有兴趣的同学可以抽空看看，就到这吧</p>

<ul>
  <li>
    <p><a href="https://testerhome.com/topics/5669">基于 Gtest 的单元测试入门及实践 (一)</a></p>
  </li>
  <li>
    <p><a href="https://testerhome.com/topics/5675">基于 Gtest 的单元测试入门及实践 (二)</a></p>
  </li>
  <li>
    <p><a href="https://testerhome.com/topics/6184">基于 Docker 的分布式测试系统构建 (一)</a></p>
  </li>
  <li>
    <p><a href="https://testerhome.com/topics/6187">基于 Docker 的分布式测试系统构建 (二)</a></p>
  </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>基于 Docker 的分布式测试系统构建 (二)</title>
	  <link>//pc-ads-distribution-docker</link>
	  <author>Wang Yukun</author>
	  <pubDate>2016-11-06T15:18:00+00:00</pubDate>
	  <guid>//pc-ads-distribution-docker</guid>
	  <description><![CDATA[
	     <p><strong>前言：</strong>
在基于<a href="https://testerhome.com/topics/6184">Docker的分布式测试系统构建（一）</a>中主要阐述了两个方面的内容，分别为开发此分布式测试系统的缘由以及docker基础镜像的构建和踩过的坑。在本篇中主要有4个部分的内容，分别为分布式测试系统的架构、技术实现细节简述、docker Node节点的部署，以及前端实现。</p>

<blockquote>
  <p>—-  搜狗ADTQ测试组出品</p>
</blockquote>

<hr />

<h5>一、分布式测试系统的架构</h5>
<hr />
<p>整体的测试架构主要Docker Nodes节点，Mongodb Broker，Mongodb DB, Front Web，这4个部分构成，其实现的架构简图如下所示：
<img src="/images/pc_ads_distribution/base-framework.jpg" alt="" />
现在就每个部分简要叙述：</p>

<p><em>1. Docker Node节点简述</em>
Docker Node节点主要有Celery 异步框架，Celery Worker任务，Nosetests 测试框架，Mock服务构成。
其分布式实现主要有Celery来完成，通过编写Celery worker 任务来实现具体的测试逻辑。由于业务逻辑本身的需求情况，分层级的调用关系成为实现的有效途径。Celery Worker从Mongodb Broker接收需要完成的任务信息，然后调用Node节点本身的Nosetests框架和Shell脚本，最后调用Mock Service辅助完成测试任务。Celery Worker完成待定的测试任务后，将测试结果写入MongoBD 数据库中以备前端调用。</p>

<p><em>2. Docker Swarm</em>
由于本系统的docker node节点并不多，考虑实现成本以及后续管理难易程度，本系统使用Swarm来管理docker node节点。如果docker node节点众多，可以考虑k8s。关于docker swarm在第二部分会进行说明，这里不在叙述。</p>

<p><em>3. Mogondb</em>
在本系统中，MongoDB主要有两个方面的用途。用途一，作为Celery 的broker，接收前端发送过来的任务请求信息，当broker中有数据时，Celery Worker从broker中获取数据，完成后续任务执行过程；用途二，作为DataBase，Celery worker完成任务后，将result.json数据写入到数据库中</p>

<p><em>4. 前端实现</em>
由于部门内当前的web系统，使用的是Flask Web框架，所以前端主要由Flask + Jquery + Bootstrap实现
整个架构实现还算比较清晰，这对后期的维护也带来了方便。</p>

<h5>二、技术实现有关细节简述</h5>
<hr />

<p><em>1. 关于使用Celery作为异步框架</em>
由于测试用例本身都是基于python来开发的，并且web系统为Flask，所以有充分的理由选择Celery,关于异步框架的选择可以参考<a href="https://testerhome.com/topics/5732">基于 Docker 集群的分布式测试系统 DDT (DockerDistributedTest)</a>文章中对异步框架的对比。</p>

<p><em>2. 关于Nosetests的插件化</em>
默认安装的nosetests是并未安装json插件的，但是提供xml格式。为了便于后续的结果处理，需要事先安装json插件。这里还有一个小插曲，由于之前从来都是使用默认的插件，都不太清楚原来nosetests也可以私自开发插件并安装，走了不少弯路。当然json的插件不需要自己再重复造轮子，可以直接下载安装。</p>

<p>由于nosetests提供了xml格式报告输出，所以第一时间选择的是xml作为最后的结果报文格式。用到–with-xunit参数，同时需要安装nosexunit插件，但是安装的过程中，需要coverage特定版本的支持，为2.85版本。但是即使安装了2.85版本的支持包，<a href="https://pypi.python.org/pypi/coverage/2.85">https://pypi.python.org/pypi/coverage/2.85</a>也同样会报错。</p>

<p>安装后，使用–with-xunit来运行，会提示如下信息：<em>NameError: global name ‘pylint’ is not defined</em>。但是pylint已经被正确安装，出现这个错误很是匪夷所思。后来以为是nosexunit的版本的问题，现在安装的是最新版本0.3.3，后来换成0.3.2和0.3.1都会出现错误，暂时还没有发现原因。所以最后还是使用json作为结果输出格式。</p>

<p><em>3. 关于测试数据以及环境准备</em>
数据更新以及运行相关环境的准备，总体来说可以有两种大的途径，可总结为远程拉取，和本地挂载。</p>

<ul>
  <li>远程拉取</li>
</ul>

<p>远程拉取可以有多种方法，第一种为通过rsync方法，将目的机中的数据远程拉取到docker node中，但是由于运行环境的数据量太大，所以当初认为并不可行。经过统计，在内网中完全拉取大小在5.5G左右的文件夹，需要6分钟左右，这个时间太长了。所以当初这个方案是被废弃了。</p>

<p>第二种方法为使用svn或者git，svn的话对于一些特别大的文件，会提示上传受到限制，这种情况下可以使用svn ignore对某些大的文件进行排除，后来发现由于文件夹太大的原因导致svn报错，使用svn ignore属性同样不能解决问题，现在svn报错也还无法查明原因。</p>

<ul>
  <li>本地挂载</li>
</ul>

<p>通过将所需要的文件传输到docker node宿主机中，然后在运行docker node的时候通过docker -v 本地挂载的形式，可以比较方便的解决环境问题。但是这样会使得部署一个node节点也复杂了一步，必须先同步环境相关数据到docker宿主机，这样又绕回了问题本身。所以本地挂载在本分布式测试系统中并不合适。</p>

<p>所以最后还是要考虑第一个方案。在仔细研究了rsync服务后，发现之前对rsync的研究并不深入，并不清楚rsync的差异性同步模式，通过这篇文章进行了详细的了解，<a href="https://segmentfault.com/a/1190000002427568">https://segmentfault.com/a/1190000002427568</a>，最后决定使用rsync的方式来进行文件同步。
举例如下：</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell">rsync -auvrtzopgP --progress --delete  --exclude <span class="s2">"core.*"</span>   --exclude <span class="s2">"your/log"</span> 192.168.56.73::root/the/des/directory/  ./ </code></pre></figure>

<p>通过设置–exclude 参数可以将不需要同步的文件排除，比如日志文件，这在实践中很有用</p>

<p><em>4. 关于分布式系统的执行粒度</em>
在第一篇文章中我有提，现在的分布式系统执行的最小粒度是文件，也就是说nosetests 在运行测试程序时，最小是全部执行某一个文件中所有的case。比如A.py文件中有10个cases，而B.py文件有50cases，那么运行过程是node1运行A.py中的所有case，node2运行B.py中的所有cases。由于A.py中的cases比较少，所以node1运行完成后，就闲置了。而总的运行时间有node2来决定，这种情况下系统的资源被浪费了。</p>

<p>当以casesID作为执行的基本单元时，这种情况就不复存在了，假如运行一个case为1分钟，那么原先需要运行50min才能运行完所有的case。而在现有的执行粒度下，只需要30min就可以运行完所有的case。关于python文件中casesID的收集，可以通过nosetests –collect-only命令来进行收集。</p>

<p><em>5. 关于Celery worker的命令</em>
由于每一个cases的运行都需要Mock Service的支持，其主程序在内存中只允许运行一个实例，所以每一个docker node节点每次只可以运行一个case，否则便会相互影响。在解决这个问题的时候走了不少弯路，后来在仔细研究了celery worker的命令后，发现可以通过celery worker的运行时参数就可以控制，当时便有一个柳暗花明又一村的感觉。
举例如下：</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell">celery -A pc_ads_distribute_worker worker -c 1 --maxtasksperchild<span class="o">=</span>1 -l INFO</code></pre></figure>

<p>其中的-c参数表示worker并发为1，–maxtasksperchild表示每一个worker最多有几个孩子，同样设置为1，这样就可以满足具体业务测试要求了</p>

<h5>三、docker node节点部署</h5>
<hr />

<p>在已经有了docker 镜像后，需要搭建私有的docker registry来方面docker宿主机更新docker镜像，关于docker 私有registry的搭建可以参考如下的网址，这里不再累述了：</p>

<ul>
  <li>
    <p><a href="https://github.com/docker/distribution/blob/master/docs/index.md">https://github.com/docker/distribution/blob/master/docs/index.md</a></p>
  </li>
  <li>
    <p><a href="https://github.com/docker/docker.github.io/blob/master/registry/index.md">https://github.com/docker/docker.github.io/blob/master/registry/index.md</a></p>
  </li>
  <li>
    <p><a href="http://www.open-open.com/lib/view/open1456539405281.html">http://www.open-open.com/lib/view/open1456539405281.html</a></p>
  </li>
</ul>

<p>关于具体的使用方法示例如下：</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell"><span class="c1">#Images查询地址：</span>
<span class="nb">curl  </span>http://192.168.56.73:5000/v2/_catalog
<span class="c1">#Tags查询：</span>
<span class="nb">curl  </span>http://192.168.56.73:5000/v2/pc/centos6.6_base/tags/list
<span class="c1">#具体使用方法：</span>
docker tag centos6.6:program_auto_v3.6 192.168.56.73:5000/pc/program_auto_v3.6
docker push 192.168.56.73:5000/pc/program_auto_v3.6
docker pull 192.168.56.73:5000/pc/program_auto_v3.6</code></pre></figure>

<p>由于我测试系统中，并未升级到引擎的1.2.1版本，所以需要下载额外的swarm镜像来完成，关于如何通过swarm来管理docker node镜像由于比较简单，就不多写了，有兴趣的可以参考<a href="http://dockone.io/article/227">http://dockone.io/article/227</a>来配置。</p>

<h5>四、前端部分</h5>
<hr />

<p>前端的展示主要有三个部分组成，分别为生成分布式任务、测试任务预览、测试任务统计与查询</p>

<p><em>1. 生成分布式任务及测试任务预览</em>
<img src="/images/pc_ads_distribution/distribute_auto_pic1.jpg" alt="" /></p>

<p>左边栏包含两个主要部分，分别为填写svn的地址以及上传文件。
svn地址为必填，因为分布式测试任务必须要明确是对svn的哪个版本进行的分布式测试；上传文件为可选，如果不上传文件，则运行所有测试用例，如果上传文件，则只运行上传文件中写明的测试用例文件以及确定的caseid，这个功能在只需要运行测试用例集中的某一个子集时比较有用，右边为生成的任务预览模块，每生成一次任务则新增一条记录。</p>

<p><em>2. 任务执行统计</em>
<img src="/images/pc_ads_distribution/distribute_auto_pic2.png" alt="" />
这个图比较清楚就不再说明了</p>

<p><em>3. 具体任务查询</em>
<img src="/images/pc_ads_distribution/distribute_auto_pic3.jpg" alt="" /></p>

<p>可查询某一次具体的执行情况，必须根据运行的成功还是失败，或者根据具体的文件名来查询都可以</p>

<h5>五、结语</h5>
<hr />

<p>这两篇算是对之前所做工作的一个总结吧。一天连写两篇，有种写吐了的感觉，好了，就这样吧，希望对各位童鞋有帮助……</p>


	  ]]></description>
	</item>

	<item>
	  <title>基于 Docker 的分布式测试系统构建 (一)</title>
	  <link>//pc_ads-distribution-prepare-docker</link>
	  <author>Wang Yukun</author>
	  <pubDate>2016-10-25T19:18:00+00:00</pubDate>
	  <guid>//pc_ads-distribution-prepare-docker</guid>
	  <description><![CDATA[
	     <p><strong>前言</strong></p>

<p>关于如何运用docker来解决现实问题并非是一个新鲜的问题，关于docker在测试方面的应用也有很多的文章，本篇是在前人的基础上研究了如何结合业务逻辑构建基于docker的分布式测试系统。当然初次研究肯定有很多不完善的地方，希望抛砖引玉，如果在阅读过程中有什么问题，欢迎大家留言交流。废话不多说了，本系列共2篇6个部分，涵盖了从项目开始到结束的所有基本过程。本篇介绍前2个部分，分别为构建测试系统的需求以及搭建docker镜像，希望本篇文章对你有所帮助。</p>

<blockquote>
  <p>—-  搜狗ADTQ测试组出品</p>
</blockquote>

<hr />

<h5> 一、为何要做这件事 </h5>
<p>现在部门内每次有新的需求上线，都会对之前所有的cases进行回归。cases的数量比较大，每次回归case需要花费很长的时间，部门内现在已有一个分布式的回归工具，是基于Jenkins的api和Shell来做的，虽然实现了基本的分布式的功能，但是也有一些弊端在后续的实践中慢慢显现，主要有以下几个方面：</p>

<ol>
  <li>
    <p><em>case回归的时间很长</em>。case回归的时间长主要有两个方面的原因造成：第一个原因是分布式节点比较少，这使得分布式的优势并没有完全凸显出来；第二个原因是轮询检查子节点的完成情况，并设置超时的时间，超时时间过短则不能完成收集子节点结果的任务，而超时时间过长则进一步延长了case回归的时间</p>
  </li>
  <li>
    <p><em>分布式子节点新增困难</em>。当case量上升，需要新增子节点的时候，发现这并非是一件很容易的事情。由于子节点是jenkins的node节点，所以每次新增节点都相当于部署一个jenkins节点，并需要将任务代码rsync到新的节点中。这对于一个新手来说是很不方便的，不利于后期维护。</p>
  </li>
  <li>
    <p><em>结果展示不够直观</em>。现有的结果展示只有邮件的形式，当运行完成之后通过邮件来通知分布式程序运行的结果，如果你想查看某一个文件中case的执行情况，比如该文件中有多少case成功，或者有多少case失败，抱歉，这并不提供这个功能。你收到的邮件只是一堆失败case的集合。</p>
  </li>
</ol>

<p>当然还有一些其他的弊端，但是主要的问题就是以上的三个方面。后续在解决这三个问题的基础上，也完善了其他的功能，比如case的执行粒度、case的执行情况统计等等。所以在充分调研了现有的分布式工具的基础上，我们提出了新的需求，新需求主要有以下几个方面：</p>

<ul>
  <li>回归case的时间要尽可能的短，最起码要比现有的执行时间短</li>
  <li>case的执行粒度要尽可能的细，现有框架的case是以文件作为最小的执行粒度，而我们要做的是以caseid作为分布调度的基本粒度</li>
  <li>回归结果的展示要更直观，现有的框架仅能够完成失败case的收集并邮件通知，我们要做的是分布式结果收集、统计、展示、查询这四个维度</li>
</ul>

<p>有了需求我们才开始着手新分布式测试工具的开发工作，后续的章节将会从各个方面进行阐述。</p>

<h5>二、构建Docker Images 以及踩过的坑</h5>
<hr />

<p>对于一个刚开始接触docker的新手，一切都是新的，所以就从最开始说起，说说搭建docker镜像的那些事以及踩过的那些坑吧。。。</p>

<p><strong><em>1、搭建基础docker镜像</em></strong></p>

<p><em>Build docker镜像</em>之前，首先要了解的是你的服务程序是运行在哪个linux版本之下的，是Ubuntu还是Redhat或者其他，尽量选择与现有的平台一致的镜像，如果能具体到linux的版本号就最好了。当然如果你说我的程序是通用类型，具体的版本并不重要，那么选择一个你熟悉的镜像就ok了。比如我的服务端程序是运行在redhat6.5下，那么我会选择Centos6.5的版本作为我的基础镜像。</p>

<p>选择与现有平台一致的镜像有利于后续问题的排查，一般你对服务端程序代码的熟悉程度肯定比不了开发，甚至连一知半解都做不到，如果选择不一致的运行平台，如果出现了问题，你可能无法确定是什么原因导致的，是平台？ or 自有的服务端程序? ,而选择一致性平台则排除了这一问题。</p>

<p>服务端程序以c++为例，都会依赖很多的库，而下载下来的镜像是纯净的系统，所以第一步就是按照程序运行的依赖包。如果开发能给出一个依赖包的列表最好，如果不能，那么尝试着运行程序，将缺少的依赖包记录下来，以便制作dockerfile文件。当你尝试着将所有的依赖包安装完整，并且服务端程序可以正常的启动起来，那么dockerfile文件也就差不多制作完成了。</p>

<p>关于dockerfile文件的基础语法我就不再这里详述了，不懂的 搜狗（这是广告，哈哈…）一下吧。下面是我自己制作的dockerfile文件，或许对你有些帮助</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell"><span class="c1"># Dockfile to install bidding module dependency</span>
<span class="c1"># Based on Centos:6.5</span>
 
<span class="k">FROM </span>centos:6.5
 
<span class="c1"># to replace the origin CentOS-Base.repo</span>
WORKDIR /etc/yum.repos.d
RUN <span class="nb">mv </span>CentOS-Base.repo CentOS-Base.repo.backup
 
<span class="c1"># Add new CentOS-Base.repo</span>
ADD CentOS-Base.repo /etc/yum.repos.d/
 
<span class="c1"># Install dependency package</span>
 
RUN yum install gcc g++ gcc-c++
RUN yum install <span class="nb">curl </span>libcurl-devel
RUN yum install boost boost-devel boost-doc
RUN yum instlal zlib zlib-devel
RUN yum install openssl openssl-devel
 
<span class="c1"># Set CXX and CC</span>
 
RUN <span class="nb">echo</span> <span class="s2">"export CC='gcc -std=gnu99'"</span>    &gt;&gt; /etc/profile
RUN <span class="nb">echo</span> <span class="s2">"export CXX='g++ -std=gnu++0x'"</span> &gt;&gt; /etc/profile
 
CMD <span class="o">[</span><span class="s2">"/bin/bash"</span><span class="o">]</span></code></pre></figure>

<p><strong><em>2、从安装docker到构建完镜像踩过的那些坑</em></strong>
从开始接触到后续构建完成，一路走来，跌跌撞撞，幸好问题都已解决，现就碰到的问题与大家分享一下，或许你也正被其中的某一问题所困扰</p>

<p><em>（1）关于docker安装过程中，离线安装的问题（仅限centos系列）:</em>
docker是可以离线安装的，有离线安装包。如果是离线安装则需要按照cgroup依赖包，<a href="http://mirrors.163.com/centos/6/os/x86_64/Packages/">http://mirrors.163.com/centos/6/os/x86_64/Packages/</a>。在这篇文章中写的比较清楚：<a href="http://www.iyunv.com/thread-149007-1-1.html">http://www.iyunv.com/thread-149007-1-1.html</a>，可根据Centos的版本以及安装包依赖，切记不可照搬照抄。如果是可以上外网，最好还是线上安装吧，比如在Ubuntu下，docker的安装一条命令就可以了：
<code class="highlighter-rouge">
curl -sSL https://get.daocloud.io/docker | sh
</code></p>

<p><em>（2）关于centos6下升级docker引擎到1.2.1版本</em>
docker引擎的1.2.1版本集成了新的swarm，所以如果有可能还是使用1.2.1以后版本的docker。但是对于centos6来说，如果要升级到1.2.1版本，则安装的包需要依赖systemd，但Centos6无法安装systemd。</p>

<p>关于这个问题的回答可详细查看：<a href="http://stackoverflow.com/questions/28347694/how-to-install-systemd-on-centos-6-6">http://stackoverflow.com/questions/28347694/how-to-install-systemd-on-centos-6-6</a>，其中在这篇文章说的在Centos6中安装docker-engine1.2.1，会出现依赖包缺失的错误。<a href="http://blog.csdn.net/weiguang1017/article/details/52293235">http://blog.csdn.net/weiguang1017/article/details/52293235</a>，这篇文章也介绍了如何安装，但是我尝试后还是无法在centos6下无法升级到1.2.1以上版本，如果有成功的同学，麻烦告知，谢谢</p>

<p><em>（3）关于修改devicemapper引擎的相关参数（最大的坑）</em>
当你的docker镜像过大时，比如大于10G，那么默认的devicemapper引擎是会报错的，因为docker service初始化的时候，默认分配的存储空间最大也就是10G，所以必须要修改这个参数，并重启docker service。关于修改这个参数，足足搞了一天，差点都放弃了，因为按照网上的资料所有的更改都无法生效，具体方法如下：</p>

<p>第一种方法为service docker start 之前修改，其修改的内容就是增加–storage-opt dm.basesize=30G选项；第二种方法为调用脚本动态增加，具体的操作方法可以参照如下：<a href="http://blog.chinaunix.net/uid-20788636-id-5029770.html">http://blog.chinaunix.net/uid-20788636-id-5029770.html</a>。</p>

<p>先说第二种方法，在运行脚本的过程中，出现以下的错误：<em>resize2fs: Device or resource busy while trying to open /dev/mapper/docker-253:1-1270544-d2d2cef71c86910467c1afdeb79c1a008552f3f9ef9507bb1e04d77f2ad5eac4。</em>因为此脚本主要是调用resize2f函数来进行动态的扩存，但是由于centos6文件格式的为xfs，对比并不支持，所以此方法行不通。对于centos6来说，还可以统统xfs_growfs来进行扩存，但是对比并不熟悉，研究了一些时间，感觉也没有什么头绪，暂时放弃了。关于resize2f调整rootfs可以参照<a href="http://www.111cn.net/sys/linux/87656.htm">http://www.111cn.net/sys/linux/87656.htm</a></p>

<p>但是对于第一种方法，也是会报错，报错的信息如下：<em>Error starting daemon: error initializing graphdriver: Unknown option dm.basesize</em>。所以两种方法现在都无法达到本来预期的目的，当做一些事情的时候，忽然感觉所有的事情都在阻碍你向前进，这个时候应该静下心，努力排查可能出现的错误，找出其中的蛛丝马迹，应该相信你并非是第一个碰到这个题目的人，合理的利用google。经过很久的排查，终于在github的一个issue里面找到了可能存在的问题，该网页如下：<a href="https://github.com/docker/docker/issues/21171">https://github.com/docker/docker/issues/21171</a>。其中的一位同学做了一下的事情：
<img src="/images/docker/answer.png" alt="" /></p>

<p>再指定storage-opt的时候，同时也指定了storage-driver。抱着试一试的心态，添加了上述参数，果然可以成功的改变container中rootfs中的大小，算做经验教训吧。其他有用的选项可参考如下示例：DOCKER_STORAGE_OPTIONS=”–storage-opt dm.loopdatasize=2000G –storage-opt dm.loopmetadatasize=10G –storage-opt dm.fs=ext4 –storage-opt  dm.basesize=20G”</p>

<ul>
  <li>
    <p>dm.loopdatasize=2000G是指存放数据的数据库空间为2t，默认是100g</p>
  </li>
  <li>
    <p>dm.loopmetadatasize=10G是存放Metadata数据空间为10g，默认是2g</p>
  </li>
  <li>
    <p>dm.fs=ext4是指容器磁盘分区为ext4</p>
  </li>
  <li>
    <p>dm.basesize=20G是指容器根分区默认为20g，默认是10g</p>
  </li>
</ul>

<p><em>（4）关于docker镜像拉取以及squid代理</em>
现在很多公司的机子都是内网环境，无法连接外网，无法连接外网也就无法从docker的registry中拉取镜像，除非你们公司搭建了私有的registry并且包含你所需要的镜像。如果没有，那么有两种途经来解决:</p>

<ul>
  <li>
    <p>第一种方法，就是先在可访问外网的机子上（一般个人本机可以访问外网）下载所需要的docker镜像，然后通过docker save命令将其保存为本地镜像，然后导出后再通过docker load 命令将其导入到所需要的docker宿主机中。这种方法比较麻烦，但是好在一般都能实现，对于确实无法连接外网的宿主机也不失为一种办法。</p>
  </li>
  <li>
    <p>第二种办法，就是在内网中找一台可以访问外网的机子，然后在该机子上搭建squid代理服务器，docker的宿主机可以通过配置代理来拉取镜像。关于squlid代理服务器运行可以参照一下命令:</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell">docker run --name squid -d --restart<span class="o">=</span>always <span class="se">\</span>
  --publish 3128:3128 <span class="se">\</span>
  --volume /search/wangyukun/log/cache:/var/spool/squid3 <span class="se">\</span>
  --volume /search/wangyukun/log/squid_log/:/var/log/squid3 <span class="se">\</span>
  sameersbn/squid:3.3.8-19</code></pre></figure>

<p>当然前提是你已经通过第一种方法安装了squid镜像，这属于一次辛苦多次收益，哈哈，如果你们内网的所有自己都无法连接外网，那么只能通过第一种方法了。启动squid代理服务后，那么就要docker宿主机上配置代理服务，以centos6举例，修改/etc/sysconfig/docker 配置文件的内容如下：</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell"><span class="nv">other_args</span><span class="o">=</span><span class="s2">"--graph=/search/odin/wangyukun/docker --insecure-registry 10.142.97.235:5000 --storage-driver devicemapper --storage-opt dm.basesize=100G --storage-opt dm.loopdatasize=2000G --storage-opt dm.loopmetadatasize=10G"</span>
<span class="nv">HTTP_PROXY</span><span class="o">=</span>http://your_squid_service_ip:3128
<span class="nv">http_proxy</span><span class="o">=</span><span class="nv">$HTTP_PROXY</span>
<span class="nv">HTTPS_PROXY</span><span class="o">=</span><span class="nv">$HTTP_PROXY</span>
<span class="nv">https_proxy</span><span class="o">=</span><span class="nv">$HTTP_PROXY</span>
<span class="nb">export </span>HTTP_PROXY HTTPS_PROXY http_proxy https_proxy</code></pre></figure>

<p>这样重启docker service 就可以了。镜像搭建以及走过的坑就先说到这吧，剩下的部分第二篇再续。。。</p>


	  ]]></description>
	</item>

	<item>
	  <title>基于 Gtest 的单元测试入门及实践 (二)</title>
	  <link>//gtest-unittest-2</link>
	  <author>Wang Yukun</author>
	  <pubDate>2016-08-12T18:18:00+00:00</pubDate>
	  <guid>//gtest-unittest-2</guid>
	  <description><![CDATA[
	     <p><strong>前言</strong>
在第一章里，主要以gtest自带的samples为例，简单阐述了为普通的成员函数，以及类中的成员函数进行单元测试，在这部分主要介绍如何利用gtest中的固件以及超级固件来优化单元测试工作。在现在的互联网企业对底层模块（C++编写）进行单元测试的并不多见，大家习惯从上层来覆盖底层的功能，这样有好的地方也有不好的地方，这个后续再说吧。本篇文章分成两个部分，第一部分是介绍固件以及超级固件，第二部分是实践以及感悟，如果对第一部分的介绍不感兴趣，可以跳过直接看第二部分</p>

<hr />
<p><strong>一、中级</strong></p>

<ul>
  <li>测试固件   主要包含两个文件，sample3-inl.h 以及 sample3_unittest.cc</li>
</ul>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*sample3-inl.h*/</span>
<span class="cp">#ifndef GTEST_SAMPLES_SAMPLE3_INL_H_
#define GTEST_SAMPLES_SAMPLE3_INL_H_
</span>
<span class="cp">#include &lt;stddef.h&gt;
</span>

<span class="c1">// Queue is a simple queue implemented as a singled-linked list.
// Queue类是一个由单链表构建的队列
// The element type must support copy constructor.
// 队列中的元素必须支持拷贝构造函数
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span>  <span class="c1">// E is the element type
</span><span class="k">class</span> <span class="nc">Queue</span><span class="p">;</span>

<span class="c1">// QueueNode is a node in a Queue, which consists of an element of
// type E and a pointer to the next node.
//
// 队列节点由类型为E的元素，以及指向下一个节点的指针所构成
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span>  <span class="c1">// E is the element type
</span><span class="k">class</span> <span class="nc">QueueNode</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Gets the element in this node.
</span>  <span class="c1">// 获取节点中元素的值
</span>  <span class="k">const</span> <span class="n">E</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">element_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Gets the next node in the queue.
</span>  <span class="c1">// 获取下一个节点
</span>  <span class="n">QueueNode</span><span class="o">*</span> <span class="n">next</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">next_</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">QueueNode</span><span class="o">*</span> <span class="n">next</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">next_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="c1">// Creates a node with a given element value.  The next pointer is
</span>  <span class="c1">// set to NULL.
</span>  <span class="c1">// 对于给定的值生成一个节点，其指向下个节点的指针被设为空
</span>  <span class="k">explicit</span> <span class="n">QueueNode</span><span class="p">(</span><span class="k">const</span> <span class="n">E</span><span class="o">&amp;</span> <span class="n">an_element</span><span class="p">)</span> <span class="o">:</span> <span class="n">element_</span><span class="p">(</span><span class="n">an_element</span><span class="p">),</span> <span class="n">next_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// We disable the default assignment operator and copy c'tor.
</span>  <span class="c1">// 我们将默认的赋值构造函数以及拷贝构造函数设置为无效
</span>  <span class="k">const</span> <span class="n">QueueNode</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">QueueNode</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">QueueNode</span><span class="p">(</span><span class="k">const</span> <span class="n">QueueNode</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="n">E</span> <span class="n">element_</span><span class="p">;</span>
  <span class="n">QueueNode</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span>  <span class="c1">// E is the element type.E是元素的类型
</span><span class="k">class</span> <span class="nc">Queue</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Creates an empty queue.
</span>  <span class="c1">// 生成一个空的队列
</span>  <span class="n">Queue</span><span class="p">()</span> <span class="o">:</span> <span class="n">head_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">last_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">size_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// D'tor.  Clears the queue.
</span>  <span class="o">~</span><span class="n">Queue</span><span class="p">()</span> <span class="p">{</span> <span class="n">Clear</span><span class="p">();</span> <span class="p">}</span>

  <span class="c1">// Clears the queue.
</span>  <span class="c1">// 清空队列
</span>  <span class="kt">void</span> <span class="n">Clear</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 1. Deletes every node.
</span>      <span class="c1">// 删除每一个节点
</span>      <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
      <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">();</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="p">;)</span> <span class="p">{</span>
        <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">();</span>
      <span class="p">}</span>

      <span class="c1">// 2. Resets the member variables.
</span>      <span class="c1">// 重置成员变量
</span>      <span class="n">head_</span> <span class="o">=</span> <span class="n">last_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="n">size_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Gets the number of elements.
</span>  <span class="c1">// 获取队列中元素的数目
</span>  <span class="kt">size_t</span> <span class="n">Size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">size_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Gets the first element of the queue, or NULL if the queue is empty.
</span>  <span class="c1">// 获取队列中的第一个元素，如果队列为空，则返回NULL
</span>  <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">Head</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">head_</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">Head</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">head_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Gets the last element of the queue, or NULL if the queue is empty.
</span>  <span class="c1">// 获取队列中的最后一个元素，如果队列为空，则返回NULL
</span>  <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">Last</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">last_</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">Last</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">last_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Adds an element to the end of the queue.  A copy of the element is
</span>  <span class="c1">// created using the copy constructor, and then stored in the queue.
</span>  <span class="c1">// Changes made to the element in the queue doesn't affect the source
</span>  <span class="c1">// object, and vice versa.
</span>  <span class="c1">//
</span>  <span class="c1">// 向队列的末尾添加一个元素。这个元素由拷贝构造函数生成，并被存储到队列中
</span>  <span class="c1">// 对队列中元素的改变，不会影响到原先的对象，反之亦然
</span>  <span class="kt">void</span> <span class="n">Enqueue</span><span class="p">(</span><span class="k">const</span> <span class="n">E</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">head_</span> <span class="o">=</span> <span class="n">last_</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
      <span class="n">size_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">last_</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
      <span class="n">last_</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
      <span class="n">size_</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Removes the head of the queue and returns it.  Returns NULL if
</span>  <span class="c1">// the queue is empty.
</span>  <span class="c1">// 将队列的头元素移除，并返回它的值，如果为空，则返回NULL
</span>  <span class="n">E</span><span class="o">*</span> <span class="n">Dequeue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="k">const</span> <span class="n">old_head</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
    <span class="n">head_</span> <span class="o">=</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
    <span class="n">size_</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">last_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">E</span><span class="o">*</span> <span class="n">element</span> <span class="o">=</span> <span class="k">new</span> <span class="n">E</span><span class="p">(</span><span class="n">old_head</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">());</span>
    <span class="k">delete</span> <span class="n">old_head</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">element</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Applies a function/functor on each element of the queue, and
</span>  <span class="c1">// returns the result in a new queue.  The original queue is not
</span>  <span class="c1">// affected.
</span>  <span class="c1">//
</span>  <span class="c1">// 将函数应用于队列中的元素，并将产生的结果存入新的队列中，原始的队列不受影响
</span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
  <span class="n">Queue</span><span class="o">*</span> <span class="n">Map</span><span class="p">(</span><span class="n">F</span> <span class="n">function</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">Queue</span><span class="o">*</span> <span class="n">new_queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">new_queue</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">new_queue</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">head_</span><span class="p">;</span>  <span class="c1">// The first node of the queue. 队列的头元素
</span>  <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">last_</span><span class="p">;</span>  <span class="c1">// The last node of the queue.  队列的尾元素
</span>  <span class="kt">size_t</span> <span class="n">size_</span><span class="p">;</span>  <span class="c1">// The number of elements in the queue.队列中元素的个数
</span>
  <span class="c1">// We disallow copying a queue.
</span>  <span class="c1">// 我们不允许对队列进行拷贝
</span>  <span class="n">Queue</span><span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#endif  // GTEST_SAMPLES_SAMPLE3_INL_H_</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*sample3_unittest.cc*/</span>
<span class="c1">// In this example, we use a more advanced feature of Google Test called
// test fixture.
//
// A test fixture is a place to hold objects and functions shared by
// all tests in a test case.  Using a test fixture avoids duplicating
// the test code necessary to initialize and cleanup those common
// objects for each test.  It is also useful for defining sub-routines
// that your tests need to invoke a lot.
//
// 在这个例子中，我们将会用到Google Test一个更为高级的特性，被称为测试固件。
// 测试固件的用途主要用于存放所有测试集都要使用的对象或者函数。
//
// 使用测试固件避免了重复一些代码，而这些代码对于初始化或者清除测试用例中
// 的对象又是必须的。同时，测试固件对于定义你测试中需要调起的子例程也很有帮助
// &lt;TechnicalDetails&gt;
//
// The tests share the test fixture in the sense of code sharing, not
// data sharing.  Each test is given its own fresh copy of the
// fixture.  You cannot expect the data modified by one test to be
// passed on to another test, which is a bad idea.
//
// The reason for this design is that tests should be independent and
// repeatable.  In particular, a test should not fail as the result of
// another test's failure.  If one test depends on info produced by
// another test, then the two tests should really be one big test.
//
// The macros for indicating the success/failure of a test
// (EXPECT_TRUE, FAIL, etc) need to know what the current test is
// (when Google Test prints the test result, it tells you which test
// each failure belongs to).  Technically, these macros invoke a
// member function of the Test class.  Therefore, you cannot use them
// in a global function.  That's why you should put test sub-routines
// in a test fixture.
//
//技术细节：
//
//这些测试用例测试固件，在一定意义上是指的代码的共享，和不是数据的共享。
//这样设计的原因是，测试用例应该是独立以及可重复的。特别是当一个测试失败时
//不应该影响其他测试的执行。如果一个测试依赖于另一个测试所产生的结果，那么
//这两个测试应该合并为一个大的测试。
//
//指示测试成功(EXPECT_TRUE)或者失败(EXPECT_FAIL)的宏需要知道当前的测试是那
//一个测试用例(当Goole Test 打印失败的结果时，它告诉你这个失败从属于那个测试),
//从技术的角度来说，这些宏将调用一个Test类的成员函数。因此你不能在全局的函数中
//使用这些宏，这就是你为什么要把测试子例程放入测试固件中的原因。
//
// &lt;/TechnicalDetails&gt;
</span>
<span class="cp">#include "sample3-inl.h"
#include "gtest/gtest.h"
</span>
<span class="c1">// To use a test fixture, derive a class from testing::Test.
// 为了使用测试固件，须从Test类中派生一个类
//
</span><span class="k">class</span> <span class="nc">QueueTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">testing</span><span class="o">::</span><span class="n">Test</span> <span class="p">{</span>
 <span class="k">protected</span><span class="o">:</span>  <span class="c1">// You should make the members protected s.t. they can be
</span>             <span class="c1">// accessed from sub-classes.
</span>             <span class="c1">// 你应该将成员变量声明为保护类型，这样它们将只能被子类访问
</span>
  <span class="c1">// virtual void SetUp() will be called before each test is run.  You
</span>  <span class="c1">// should define it if you need to initialize the varaibles.
</span>  <span class="c1">// Otherwise, this can be skipped.
</span>  <span class="c1">//
</span>  <span class="c1">// 虚函数Setup(),在每一个测试运行之前就被调用，所以如果你需要初始化一些
</span>  <span class="c1">// 变量，你应该在这个地方进行定义，不需要可以跳过
</span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">q1_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">q2_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">q2_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// virtual void TearDown() will be called after each test is run.
</span>  <span class="c1">// You should define it if there is cleanup work to do.  Otherwise,
</span>  <span class="c1">// you don't have to provide it.
</span>  <span class="c1">//
</span>  <span class="c1">// virtual void TearDown() {
</span>  <span class="c1">// }
</span>  <span class="c1">//
</span>  <span class="c1">// 虚函数TearDown()在每一个测试运行之后被调用，如果你需要做一些清理工作
</span>  <span class="c1">// 可以在这个函数中定义。否则你可以忽略它
</span>
  <span class="c1">// A helper function that some test uses.
</span>  <span class="c1">// 帮助函数用于测试
</span>  <span class="k">static</span> <span class="kt">int</span> <span class="n">Double</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// A helper function for testing Queue::Map().
</span>  <span class="c1">// 帮助函数用于测试 Queue::Map()
</span>  <span class="c1">//
</span>  <span class="kt">void</span> <span class="n">MapTester</span><span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Creates a new queue, where each element is twice as big as the
</span>    <span class="c1">// corresponding one in q.
</span>    <span class="c1">// 生成一个新的队列，队列中的元素是原队列元素的两倍
</span>    <span class="k">const</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span> <span class="k">const</span> <span class="n">new_q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">Map</span><span class="p">(</span><span class="n">Double</span><span class="p">);</span>

    <span class="c1">// Verifies that the new queue has the same size as q.
</span>    <span class="c1">// 判断元队列与新队列是否有相同的大小
</span>    <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">(),</span> <span class="n">new_q</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">());</span>

    <span class="c1">// Verifies the relationship between the elements of the two queues.
</span>    <span class="c1">// 验证两个队列中，元素的关系
</span>    <span class="k">for</span> <span class="p">(</span> <span class="k">const</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">(),</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">new_q</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">();</span>
          <span class="n">n1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">n1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">(),</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">n2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n1</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">(),</span> <span class="n">n2</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">delete</span> <span class="n">new_q</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Declares the variables your tests want to use.
</span>  <span class="c1">// 声明测试中需要用到的变量
</span>  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q0_</span><span class="p">;</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q1_</span><span class="p">;</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q2_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// When you have a test fixture, you define a test using TEST_F
// instead of TEST.
// 当你定义了测试固件时，应该使用TEST_F来代替TEST
</span>
<span class="c1">// Tests the default c'tor.
// 测试默认构造函数
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span> <span class="n">DefaultConstructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// You can access data in the test fixture here.
</span>  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span> <span class="n">q0_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// Tests Dequeue().
// 测试出队列
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span> <span class="n">Dequeue</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">q0_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">q1_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span> <span class="n">q1_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
  <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">q2_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1u</span><span class="p">,</span> <span class="n">q2_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
  <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Tests the Queue::Map() function.
// 测试队列中的Map()函数
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span> <span class="n">Map</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MapTester</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0_</span><span class="p">);</span>
  <span class="n">MapTester</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q1_</span><span class="p">);</span>
  <span class="n">MapTester</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q2_</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>测试固件在单元测试中用到的非常多，因为它提供了一种数据共享的方法，同时也保证了各测试用例之间并不会相互影响。例如在本例中，每次在进行测试时，都需要构建测试数据，也就是将数据插入队列中，如果没有测试固件，则需要在每个测试用例中都重复这个操作。</p>

<p>可以看到测试固件的使用简化了单元测试的复杂性，在实际应用中，如果可以使用测试固件就尽量使用测试固件，有一点需要注意的是，如果使用测试固件，则对应的宏应该使用TEST_F,并且第一个参数应该为测试固件的名字。</p>

<ul>
  <li>超级测试固件
本例中主要包含sample1.h,sample1.cc,sample3-inl.h,sample5_unittest.cc</li>
</ul>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*sample5_unittest.cc*/</span>
<span class="c1">// This sample teaches how to reuse a test fixture in multiple test
// cases by deriving sub-fixtures from it.
// 
// 这个例子主要用于展示，如何通过从测试固件中派生子固件，在多重测试中重用
// 测试固件。
//
// When you define a test fixture, you specify the name of the test
// case that will use this fixture.  Therefore, a test fixture can
// be used by only one test case.
//
// 当你定义一个测试固件时，你确定这个使用测试固件的测试用例集的名称，因此
// 一个测试固件只能够被一个测试用例集所使用
//
// Sometimes, more than one test cases may want to use the same or
// slightly different test fixtures.  For example, you may want to
// make sure that all tests for a GUI library don't leak important
// system resources like fonts and brushes.  In Google Test, you do
// this by putting the shared logic in a super (as in "super class")
// test fixture, and then have each test case use a fixture derived
// from this super fixture.
//
// 有些时候，不止一个测试用例集需要使用相同或者有细微差异的测试固件。例如
// 你想确定，针对一个GUI库的所有测试用例集都没有泄漏重要的系统资源，如字体
// 和画刷。在Google Test中，你可以把共享的逻辑放在一个超级测试固件中，然后
// 每一个测试用例集所使用的测试固件都可以从这个超级测试固件类中派生。
</span>
<span class="cp">#include &lt;limits.h&gt;
#include &lt;time.h&gt;
#include "sample3-inl.h"
#include "gtest/gtest.h"
#include "sample1.h"
</span>
<span class="c1">// In this sample, we want to ensure that every test finishes within
// ~5 seconds.  If a test takes longer to run, we consider it a
// failure.
//
// We put the code for timing a test in a test fixture called
// "QuickTest".  QuickTest is intended to be the super fixture that
// other fixtures derive from, therefore there is no test case with
// the name "QuickTest".  This is OK.
//
// Later, we will derive multiple test fixtures from QuickTest.
//
// 在这里例子中，我们需要确保每一个测试都在5s内结束。如果一个测试运行的时间
// 长于5s，我们就认为这个测试失败了
//
// 我们在测试固件中放置计算测试花费时间的代码，并将其称为QuickTest。QuickTest
// 作为超级测试固件而存在，而后续的测试固件都从其派生。所以并没有测试用例集所
// 绑定的测试固件被命名为QuickTest,之后我们将从QuickTest类中派生出多个测试固件
//
</span><span class="k">class</span> <span class="nc">QuickTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">testing</span><span class="o">::</span><span class="n">Test</span> <span class="p">{</span>
 <span class="k">protected</span><span class="o">:</span>
  <span class="c1">// Remember that SetUp() is run immediately before a test starts.
</span>  <span class="c1">// This is a good place to record the start time.
</span>  <span class="c1">// SetUp()函数，在一个测试开始之前执行，所以在其内部可以用来记录开始时间
</span>  <span class="c1">//
</span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">start_time_</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// TearDown() is invoked immediately after a test finishes.  Here we
</span>  <span class="c1">// check if the test was too slow.
</span>  <span class="c1">//
</span>  <span class="c1">// TearDown()函数在一个测试结束之后被调起，所以在这里我们检测一个测试是否太慢
</span>  <span class="c1">//
</span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">TearDown</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Gets the time when the test finishes
</span>    <span class="k">const</span> <span class="kt">time_t</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Asserts that the test took no more than ~5 seconds.  Did you
</span>    <span class="c1">// know that you can use assertions in SetUp() and TearDown() as
</span>    <span class="c1">// well?
</span>    <span class="c1">//
</span>    <span class="c1">// 下面是断言的结果
</span>    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time_</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"The test took too long."</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// The UTC time (in seconds) when the test starts
</span>  <span class="c1">// 超级固件定义的开始时间成员变量
</span>  <span class="kt">time_t</span> <span class="n">start_time_</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// We derive a fixture named IntegerFunctionTest from the QuickTest
// fixture.  All tests using this fixture will be automatically
// required to be quick.
//
// 我们从QuickTest超级固件中派生出一个名为IntergerFunctionTest的测试固件
// 所有使用这个测试固件的测试，都将自动计算测试运行所花费的时间
//
</span><span class="k">class</span> <span class="nc">IntegerFunctionTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QuickTest</span> <span class="p">{</span>
  <span class="c1">// We don't need any more logic than already in the QuickTest fixture.
</span>  <span class="c1">// Therefore the body is empty.
</span>  <span class="c1">// 由于不需要添加新的测试逻辑，所以此函数体为空
</span>  <span class="c1">//
</span><span class="p">};</span>


<span class="c1">// Now we can write tests in the IntegerFunctionTest test case.
// 现在在IntegerFunctionTest测试集中，编写测试用例
//
// Tests Factorial()
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">IntegerFunctionTest</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Tests factorial of negative numbers.
</span>  <span class="c1">//sleep(6);
</span>  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_GT</span><span class="p">(</span><span class="n">Factorial</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// Tests factorial of 0.
</span>  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

  <span class="c1">// Tests factorial of positive numbers.
</span>  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">40320</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>


<span class="c1">// Tests IsPrime()
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">IntegerFunctionTest</span><span class="p">,</span> <span class="n">IsPrime</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Tests negative input.
</span>  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="n">INT_MIN</span><span class="p">));</span>

  <span class="c1">// Tests some trivial cases.
</span>  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>

  <span class="c1">// Tests positive input.
</span>  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">23</span><span class="p">));</span>
<span class="p">}</span>


<span class="c1">// The next test case (named "QueueTest") also needs to be quick, so
// we derive another fixture from QuickTest.
//
// The QueueTest test fixture has some logic and shared objects in
// addition to what's in QuickTest already.  We define the additional
// stuff inside the body of the test fixture, as usual.
//
// 同样，可以从超级固件中派生出另一个测试固件用于队列测试，QueueTest固件
// 还有一些其他的逻辑，以及共享的对象除了计算测试时间之外，所以我们像平常
// 一样在测试固件内部进行定义
//
</span><span class="k">class</span> <span class="nc">QueueTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QuickTest</span> <span class="p">{</span>
 <span class="k">protected</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// First, we need to set up the super fixture (QuickTest).
</span>    <span class="c1">// 首先需要调用超级固件的setup，这个地方由于不是指针或者引用调用，所以
</span>    <span class="c1">// 不涉及多态
</span>    <span class="n">QuickTest</span><span class="o">::</span><span class="n">SetUp</span><span class="p">();</span>

    <span class="c1">// Second, some additional setup for this fixture.
</span>    <span class="n">q1_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">q2_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">q2_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// By default, TearDown() inherits the behavior of
</span>  <span class="c1">// QuickTest::TearDown().  As we have no additional cleaning work
</span>  <span class="c1">// for QueueTest, we omit it here.
</span>  <span class="c1">//
</span>  <span class="c1">// 之前已有翻译，这里不再赘述
</span>  <span class="c1">//
</span>  <span class="c1">// virtual void TearDown() {
</span>  <span class="c1">//   QuickTest::TearDown();
</span>  <span class="c1">// }
</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q0_</span><span class="p">;</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q1_</span><span class="p">;</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q2_</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// Now, let's write tests using the QueueTest fixture.
// 现在，让我们使用QueueTest 测试固件来写测试用例
</span>
<span class="c1">// Tests the default constructor.
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span> <span class="n">DefaultConstructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span> <span class="n">q0_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// Tests Dequeue().
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span> <span class="n">Dequeue</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">q0_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">q1_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span> <span class="n">q1_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
  <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">q2_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1u</span><span class="p">,</span> <span class="n">q2_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
  <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// If necessary, you can derive further test fixtures from a derived
// fixture itself.  For example, you can derive another fixture from
// QueueTest.  Google Test imposes no limit on how deep the hierarchy
// can be.  In practice, however, you probably don't want it to be too
// deep as to be confusing.
//
// 如果必要的话，你也可以从已派生的固件进行再次派生。例如你可以从QueueTest
// 这个固件中再次派生。GoogleTest对你究竟从中派生多少次并没有限制，但是派生的
</span><span class="o">//</span> <span class="err">层次太深，则容易使人迷惑</span></code></pre></figure>

<p>本例中定义了一个超级固件用来计算测试用例运行的时间，每个需要计算运行时间的测试用例都可以从这个超级固件中派生。把测试固件中的共有特性抽取出来组成超级固件，不管从测试case管理的角度，还是代码的简化都有很好的效果。在实际应用中，测试固件和超级测试固件应用的最多，这并不是说其他的特性不重要，只是我现在还没有用到，关于其他特性大家可以去参考samples中其他sample的介绍。关于Gtest的入门介绍部分就到这了，后面介绍实际应用过程中遇到的问题，以及思考。</p>

<p><strong>二、实践应用以及思考</strong></p>

<p><em>1、如何将Gtest应用到现有的C++工程中？</em></p>

<p>实际的项目工程要比上面两个部分介绍的sample要复杂的多，甚至某些开发都只是负责其中的某一块，对其他的模块可能也知之甚少，如果拿到一个这样的项目要怎么入手是刚开始碰到的第一个难题。</p>

<p>首先如果这个大的项目可以拆分成一个一个独立的模块，各模块之间的联系是通过RPC或者单纯的套接字来交互，那么可以按照模块的方式来分别进行单元测试。如果无法进行拆分，其左右一个整体而存在，或者即使可以拆分成模块，但是这个模块对于单元测试还是太大，这个时候可能就需要从整体来考虑，按照以下的步骤进行：</p>

<ul>
  <li>
    <p>要对整体或者模块的Makefile文件非常的熟悉，因为只有这样，才能明白整体或者模块的文件依赖关系，才能知道哪些是可以拆分出来，哪些不可以。</p>
  </li>
  <li>
    <p>判断是否需要自定义main()函数，如果需要在main()函数中进行一些全局变量的声明或者其他的操作，那么可需要自定义main函数，如果不需要则可使用gtest自带的main函数</p>
  </li>
  <li>
    <p>如果使用将整体或者模块的main()函数，那么将main()函数中所有的内容清空，或者删除原有的Main文件，重新新建一个文件，并编写main函数。需要注意的是，如果是自己新建包含main()函数的文件，那么相应的makefile文件也需要进行改变，否则无法编译通过</p>
  </li>
  <li>
    <p>链接gtest静态库，在上述的例子中每次gtest.a和gtest_main.a都是重新生成，在实际应用中，可以事先将静态库生成，然后在makefile中进行链接。在之前强调过一次，如果使用自定义的main函数，那么链接的是gtest.a静态库，否则链接的是gtest_main.a静态库</p>
  </li>
  <li>
    <p>最后一步就是make 并运行</p>
  </li>
</ul>

<p><em>思考</em>：其实在整个单元测试实践的过程中，这一步是最难的。因为需要对整个项目或者模块都比较了解，特别是需要对原有的makefile文件非常的熟悉。有些时候工程特别大，makefile文件不止一个，可能会在公有的makefile文件中，调用子模块的makefile文件，这个时候就需要有耐心把makefile中的调用关系理清楚，然后在合适的地方添加静态链接库。有些makefile中包含了很多并不常用的特性，比如makefile的命令前缀、makefile的条件判断、makefile中的字符串函数等等可能都需要有一定的了解。如果不熟悉的童鞋，可以点击<a href="http://www.cnblogs.com/wang_yb/p/3990952.html">makefile学习</a>链接事先学习一下。</p>

<p><em>2、对模块依赖以及函数依赖的思考</em></p>

<p>如果测试某一个模块，或者函数，那么首先需要做的就是熟悉特测试的模块或者文件。熟悉的过程是编写单元测试用例的前提条件，如果原有的代码都不熟悉，那么单元测试更是无从谈起了。这个时候才开始真正单元测试的编写过程，但是又有一个问题出现了，模块依赖或者函数依赖。</p>

<p>当真正的开始编写时就会发现，gtest示例中所带的samples都是在非常理想的情况下，也就是说函数或者模块依赖关系很少或者根本就不存在依赖关系，这种情况下编写最简单，samples示例就是例子。但是在现实的项目或者模块中，会发现，即使已经将原有的代码拆分成模块，但是模块内部的依赖关系也非常的复杂。可能一个函数依赖模块中80%的代码（极端的情况下），模块中的代码高度耦合。</p>

<p>在这种高耦合模块中，如果将待测函数代码所在的文件提出来，添加单元测试框架真的是一项很费力的活，需要花费很多时间。这是由于框架中各个文件的依赖关于特别复杂，所以很难直接抽取出这一个文件，因为如果只抽取一个文件，运行过程中可能调用多个别的文件中的数据，这样很难将工程按照模块单独独立出来测试。</p>

<p>解决的办法有两种:</p>

<ul>
  <li>
    <p>如果模块耦合度虽然较高，但是也不至于到极端的情况，比如依赖模块小于30%的代码，这个时候可以将所依赖的文件单独抽取出来，重新根据这些文件构造新的makefile文件，这种情况下工作量也是很大的</p>
  </li>
  <li>
    <p>模块之间的耦合度特别高，超过50%。那么这个时候就不要考虑单独抽取了，依赖原先的makefile文件吧，从整体来进行测试</p>
  </li>
</ul>

<p><em>3、依赖关系的Mock实现</em></p>

<p>关于依赖关系的Mock，每个人都有自己的理解。很多人认为只有对外部资源比如数据库、缓存等的Mock才算是真正的Mock，或者说类似GoogleMock的用法才是正统的mock方法。这么说可能也没有错，因为每个人的理解不同，但是我理解的Mock并不仅限于对外部资源，或者通过googleMock来实现，并且googleMock的应用范围也是有局限的，需要配合虚函数和类继承来完成。关于googleMock的用法并不在本次论述之内，有兴趣的大家可以自己找来看一下。</p>

<p>在测试实践中，更多的是依赖于工程项目或者模块原有的代码来进行mock封装，解决依赖关系
以下面的代码举个例子吧</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include "../src/BiddingHeaders.h"
#include "Constant.h"
</span> 
<span class="c1">//定义文件读取及解析类
</span><span class="k">class</span> <span class="nc">DataConfig</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
            <span class="n">DataLoader</span><span class="o">*</span> <span class="n">data_loader_</span><span class="p">;</span>
            <span class="n">DataCenter</span><span class="o">*</span> <span class="n">instance_ptr</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">load_data_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">file</span><span class="p">);</span>
            <span class="c1">//construct function
</span>            <span class="n">DataConfig</span><span class="p">();</span>
<span class="p">};</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*
 * DataConfig.cpp
 */</span>
<span class="cp">#include "BiddingHeaders.h"
#include "DataConfig.h"
</span> 
<span class="n">DataConfig</span><span class="o">::</span><span class="n">DataConfig</span><span class="p">(){</span>
	<span class="c1">//DataCenter中定义了标签所对应的函数
</span>    <span class="n">instance_ptr</span><span class="o">=</span> <span class="n">DataCenter</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
    <span class="n">data_loader_</span><span class="o">=</span><span class="n">instance_ptr</span><span class="o">-&gt;</span><span class="n">get_data_loader</span><span class="p">();</span>
<span class="p">}</span>
 
<span class="c1">//set to default value
</span> 
<span class="kt">int</span> <span class="n">DataConfig</span><span class="o">::</span><span class="n">load_data_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>   
        <span class="n">LOG_ERROR</span><span class="p">(</span><span class="s">"[DataCenter][load_data_file] file name null"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 
    <span class="p">}</span>   
	
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span> <span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>   
        <span class="n">LOG_ERROR</span><span class="p">(</span><span class="s">"[DataCenter][load_data_file] error to open file: %s"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> 
    <span class="p">}</span>  
	
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MSG_BUF_LEN</span> <span class="o">*</span> <span class="mi">200</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="c1">// 对相应的标签注册响应函数，比如文件中有A标签，那么会调用DataCenter函数中change_A函数
</span>    <span class="n">data_loader_</span><span class="o">-&gt;</span><span class="n">register_op</span><span class="p">(</span><span class="s">"A"</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DataLoader</span><span class="o">::</span><span class="n">DATA_OP_FUNC</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DataCenter</span><span class="o">::</span><span class="n">change_A</span><span class="p">));</span>
    <span class="n">data_loader_</span><span class="o">-&gt;</span><span class="n">register_op</span><span class="p">(</span><span class="s">"B"</span><span class="p">,</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DataLoader</span><span class="o">::</span><span class="n">DATA_OP_FUNC</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DataCenter</span><span class="o">::</span><span class="n">change_B</span><span class="p">));</span>
    <span class="n">data_loader_</span><span class="o">-&gt;</span><span class="n">register_op</span><span class="p">(</span><span class="s">"C"</span><span class="p">,</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DataLoader</span><span class="o">::</span><span class="n">DATA_OP_FUNC</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DataCenter</span><span class="o">::</span><span class="n">change_C</span><span class="p">));</span>
 
    <span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">fp</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LOG_WARNING</span><span class="p">(</span><span class="s">"[DataCenter][load_data_file] message too long"</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 
	<span class="c1">//process_msg函数用于读取标签标记文档，并调用相对应的函数
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">data_loader_</span><span class="o">-&gt;</span><span class="n">process_msg</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">num</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">LOG_INFO</span><span class="p">(</span><span class="s">"[DataCenter][load_data_file] num: %d"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>上述代码中调用了两个类，data_loader类，以及DataCenter类，data_loader作为类成员变量从属于DataCenter类，该代码的作用是处理文本，并根据文本中的标签，调用相关的处理函数。其中data_loader类和DataCenter类为原有项目的文件，其相关的头文件包含在名为BiddingHeaders.h的文件中。</p>

<p>现在假设需要测试的模块，依赖于DataCenter::change_A,那么如何解决呢？</p>

<ul>
  <li>
    <p>如果DataCenter的文件，依赖关系比较简单，可以直接将change_A函数抽取出来，并重新封装成一个文件供调用。</p>
  </li>
  <li>
    <p>如果change_A函数的依赖关系比较复杂，比如需要依赖DataCenter中某些全局的Hash，或者公有模块，那么单独将某一个函数抽取出来就并不合适，这时可以考虑直接依赖整个DataCenter文件，而不是进行单独函数的抽取，来完成单元测试</p>
  </li>
  <li>
    <p>如果是依赖整个DataCenter文件，那么又有一个问题出现，现有的通过data_loader来调用DataCenter中的change_A函数是无法成功的，原因是change_A在DataCenter中为私有成员变量，无法在外部被调用。源代码之所以可以成功，因为data_loader本身就作为DataCenter的成员变量，所以可以调用change_A函数，那么问题又来了，如果在外部成功的调用change_A函数呢？</p>
  </li>
</ul>

<p>对于私有成员变量的调用也是有响应的解决办法，总体来说分为侵入式和非侵入式两种，如下所示:</p>

<ul>
  <li>
    <p>对于侵入式，也就是需要添加响应的代码到源文件中，声明现有的类为DataCenter的友元类(friend),这样便可以访问私有成员。由于需要改动在原先的代码中进行改动，破坏了原有的完整性，并且不利于持续集成，所以我个人并不推荐侵入式方式</p>
  </li>
  <li>
    <p>对于非侵入式，其实这个比起侵入式要简单很多，需要通过shell或者python脚本，将原有的private成员修改为public成员即可。虽然对原有的代码有改动，但是只是改动成员函数的属性，并无代码添加，所以个人推荐这种方式</p>
  </li>
</ul>

<p><em>思考</em>：这样我们就构建起了一个Mock的实现，利用的是原有模块程序的代码。可能有童鞋觉得这样也是很复杂的。确实这样做也比较复杂，但是相对于直接根据待测的模块构建依赖关系要简单的多。如果不这样做，如何构建依赖关系呢？首先change_A的功能，是根据文本的标签，向全局的某hash表中插入相对应标签的数据，那么我们先是要构造需要插入hash表的数据，如果这个数据比较简单还好一些，如果需要插入hash表的数据非常负责，那么单单构建数据这一步，就已经花费了大量的时间。其次，自己编写insert函数，将构造的数据插入hash表中，每次处理不同的标签，都要分别编写不同的函数。其实这相当于把DataCenter原有的功能又简化的重新实现了一遍，这样做的时间成本实在是太大了，两者相比，取其轻！所以最大的利用现有的代码数据，构造mock实例，是一种相对高效的做法。</p>

<p>上述所说是Mock的一种情况，那就是所测单元高度依赖全局的变量，比如例子中的全局hash。那么如果所测模块对全局变量依赖较低，但是依赖的范围比较广呢？比如某一个模块可能依赖多个类。这种情况下，可以直接构建这些类的实例，通过编写set_X函数，对类中的成员变量进行赋值，这在所依赖的类耦合度不高的情况下还是比较有效的，但是如果所依赖的类耦合度较高，类之间关联性明显，则需要根据特定的情况进行分析，并非使用set_X函数就可以解决，这样只能具体问题具体分析了。</p>

<p><em>4、杂谈</em></p>

<p><em>（1）运行和调试</em></p>

<p>当完成单元测试的编写，后面就是运行调试的阶段。没有人可以保证写的单元测试每次不调试都可正常运行，出错是很正常的。其实对于错误的调试方法，和普通的C++程序基本相同。如果在项目本身日志比较完善的情况下，可以通过日志来排查错误；其次，可以在makefile编译的时候添加-g选项，通过gdb调试器来单步执行调试，gdb调试是非常高效的，也是我最长使用的工具，对gdb不熟悉的同学可以了解一下。</p>

<p>在运行过程中，可能会出现Segment fault，这种情况下要重点检查，字符串数组是否越界，是否存在空指针。数组越界和空指针是碰到最多的情况。</p>

<p><em>（2）检测点</em></p>

<p>单元测试，并非只是验证函数或者模块的正常功能是否可以走通，更多的是验证异常情况，验证代码的异常执行路径。如果只是检测函数的正常功能，完全可以通过更高层次来验证，没必要从底层来验证。其实这和接口类测试有些相似，如果只是验证接口的正常功能，从web端或手机端就可以完成验证过程，为什么非要进行接口测试呢？其功能主要都是验证异常的情况，编写测试用例时，异常的情况一定要考虑充足。可能有童鞋会问，怎么样才算考虑充足呢？就是让你的测试用例集覆盖函数的所有执行路径，在测试过程中，结合lcov代码覆盖率检查工具，可以让你清楚的知道，你现在编写的单元测试代码覆盖了哪些路径，这两者的搭配绝对是最佳的搭档</p>

<p><em>（3）适应性</em></p>

<p>对于一些高耦合度项目或者模块，可能并不适合进行单元测试。自己应该对可进行单元测试的模块或者代码有一个清晰的认识，不能为了单元测试而进行单元测试。一般偏基础类的服务是适合做单元测试的，偏业务类的可能会不太适合，自己要做好判断，免得事倍功半。相对于实现的成本来说，上次的功能自动化测试的实现成本相比于单元测试要容易很多，所以如果可以从功能自动化进行覆盖，就没有必要再进行单元测试。具体是否适合还要自己根据项目需求进行判断</p>

<p><em>（4）整合</em></p>

<p>我们希望每次代码有更新的时候，就会进行一次单元测试，并输出相关的测试报告。gtest的输出报告支持普通的文本，以及xml格式。将gtest与Jenkins进行结合，并整合lcov代码覆盖检查，这样每次有新的代码提交都会运行，并输出测试报告，这对于测试人员查看报告是非常方便的，下面是我这边所做的截图：
<img src="/images/unittest/3.png" alt="" /></p>

<p><strong>后记：</strong>
	单元测试的内容还是太多，我也就算刚入门，需要学习的东西还有很多，上面算是初做单元测试的感悟吧，希望对有需要的同学有所帮助，同时也欢迎c++单元测试高手交流经验~</p>


	  ]]></description>
	</item>


</channel>
</rss>
