<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sometimes Things Happen For A Reason - Articles</title>
    <description>There are some things in this world will never change and some things do change,everything that has a beginning has an end </description>
    <link>
    http://airfer.github.io/</link>
    
      
      <item>
        <title>kubernetes在测试中的应用实践</title>
        
          <description>&lt;h4&gt;前言&lt;/h4&gt;
&lt;p&gt;在休假之前就想写一写kubernetes在测试中应用的一些事，后来因为各种原因被耽搁了下来。这次趁着休假期间的空闲，把应用方面的东西梳理一下，算做是对之前一段研究东西的总结。&lt;/p&gt;

</description>
        
        <pubDate>Tue, 29 Aug 2017 19:28:00 +0000</pubDate>
        <link>
        http://airfer.github.io//k8s-practice</link>
        <guid isPermaLink="true">http://airfer.github.io//k8s-practice</guid>
      </item>
      
    
      
      <item>
        <title>基于Ansible &amp;&amp; Docker的分布式系统(下)</title>
        
          <description>&lt;h4&gt;前言：&lt;/h4&gt;
&lt;p&gt;在上一篇中，我们主要从Poster入手，然后讲述了为何进行这样的技术选型，分别从docker和ansible两个方面来阐述了原因，本篇的重点在于分析集成于镜像中的Unicorn工程，以及playbook脚本的编写。&lt;/p&gt;

</description>
        
        <pubDate>Wed, 28 Jun 2017 16:28:00 +0000</pubDate>
        <link>
        http://airfer.github.io//ansible-docker-2</link>
        <guid isPermaLink="true">http://airfer.github.io//ansible-docker-2</guid>
      </item>
      
    
      
      <item>
        <title>k8s实践日记之安装篇</title>
        
          <description>&lt;p&gt;其实很早就想深入了解一下容器编排工具，但是由于各种各样的事情，被耽搁了很久。最近就抽时间认真学习了一下kubernets（K8S）,虽然对其原理还未深入的了解，但是从初步掌握的情况来看，真的是一个非常牛的框架，本系列就先从安装篇开始（Centos7下）。&lt;/p&gt;

</description>
        
        <pubDate>Mon, 22 May 2017 17:45:00 +0000</pubDate>
        <link>
        http://airfer.github.io//k8s-practic-install</link>
        <guid isPermaLink="true">http://airfer.github.io//k8s-practic-install</guid>
      </item>
      
    
      
      <item>
        <title>基于Ansible &amp;&amp; Docker的分布式系统(上)</title>
        
          <description>&lt;p&gt;从最初的V1.0的分布式用例框架，到现在已经发展到V3.0版本，功能已经越来越完善，执行效率相比第一版也有了质的提升。遇见不同，其实就是见证全新的自己，我相信我们在这条道路上会越走越好。&lt;/p&gt;

</description>
        
        <pubDate>Sat, 25 Mar 2017 17:19:00 +0000</pubDate>
        <link>
        http://airfer.github.io//ansible-docker-1</link>
        <guid isPermaLink="true">http://airfer.github.io//ansible-docker-1</guid>
      </item>
      
    
      
      <item>
        <title>服务端功能测试小记</title>
        
          <description>&lt;h4&gt;前言&lt;/h4&gt;
&lt;p&gt;过年回来之后，业务的功能测试渐渐多了起来，我之前一直负责的是PC方面的测试，而现在除了负责PC的业务测试之外，还负责无线业务的测试。骤然间自己所有的时间差不多都被功能测试任务占据了，到2月份末的时候，关于测试任务的排期都排到了4月初。&lt;/p&gt;

</description>
        
        <pubDate>Sat, 25 Mar 2017 17:19:00 +0000</pubDate>
        <link>
        http://airfer.github.io//summerize-for-server-test</link>
        <guid isPermaLink="true">http://airfer.github.io//summerize-for-server-test</guid>
      </item>
      
    
      
      <item>
        <title>年终总结2016,写在农历鸡年之前</title>
        
          <description>&lt;h4&gt;前言：&lt;/h4&gt;
&lt;p&gt;一直想抽出时间来把这一年所做的事情总结一下，但是每次开始写的时候又不知道该从何写起，毕竟一年经历了很多的事情。为了不在记述的时候产生跳跃感，我就按照时间线的顺序写吧，如果要先有一个概述的话，那2016算是稳中有升的一年~&lt;/p&gt;

</description>
        
        <pubDate>Fri, 27 Jan 2017 10:19:00 +0000</pubDate>
        <link>
        http://airfer.github.io//summerize-2016</link>
        <guid isPermaLink="true">http://airfer.github.io//summerize-2016</guid>
      </item>
      
    
      
      <item>
        <title>测试总结之述职杂谈</title>
        
          <description>&lt;h4&gt;前言:&lt;/h4&gt;

</description>
        
        <pubDate>Sat, 26 Nov 2016 10:18:00 +0000</pubDate>
        <link>
        http://airfer.github.io//summerize-report</link>
        <guid isPermaLink="true">http://airfer.github.io//summerize-report</guid>
      </item>
      
    
      
      <item>
        <title>基于 Docker 的分布式测试系统构建 (二)</title>
        
          <description>&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;
在基于[Docker的分布式测试系统构建（一）][1]中主要阐述了两个方面的内容，分别为开发此分布式测试系统的缘由以及docker基础镜像的构建和踩过的坑。在本篇中主要有4个部分的内容，分别为分布式测试系统的架构、技术实现细节简述、docker Node节点的部署，以及前端实现。&lt;/p&gt;

</description>
        
        <pubDate>Sun, 06 Nov 2016 15:18:00 +0000</pubDate>
        <link>
        http://airfer.github.io//pc-ads-distribution-docker</link>
        <guid isPermaLink="true">http://airfer.github.io//pc-ads-distribution-docker</guid>
      </item>
      
    
      
      <item>
        <title>基于 Docker 的分布式测试系统构建 (一)</title>
        
          <description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;

</description>
        
        <pubDate>Tue, 25 Oct 2016 19:18:00 +0000</pubDate>
        <link>
        http://airfer.github.io//pc_ads-distribution-prepare-docker</link>
        <guid isPermaLink="true">http://airfer.github.io//pc_ads-distribution-prepare-docker</guid>
      </item>
      
    
      
      <item>
        <title>基于 Gtest 的单元测试入门及实践 (二)</title>
        
          <description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;
在第一章里，主要以gtest自带的samples为例，简单阐述了为普通的成员函数，以及类中的成员函数进行单元测试，在这部分主要介绍如何利用gtest中的固件以及超级固件来优化单元测试工作。在现在的互联网企业对底层模块（C++编写）进行单元测试的并不多见，大家习惯从上层来覆盖底层的功能，这样有好的地方也有不好的地方，这个后续再说吧。本篇文章分成两个部分，第一部分是介绍固件以及超级固件，第二部分是实践以及感悟，如果对第一部分的介绍不感兴趣，可以跳过直接看第二部分&lt;/p&gt;

</description>
        
        <pubDate>Fri, 12 Aug 2016 18:18:00 +0000</pubDate>
        <link>
        http://airfer.github.io//gtest-unittest-2</link>
        <guid isPermaLink="true">http://airfer.github.io//gtest-unittest-2</guid>
      </item>
      
    
      
      <item>
        <title>基于 Gtest 的单元测试入门及实践 (一)</title>
        
          <description>&lt;h5&gt;前言:&lt;/h5&gt;
&lt;p&gt;其实这并不是关于Gtest学习入门的资料，我希望读者在读这篇文件之前还是要对Googletest的单元测试框架有所了解。为了让读者比较容易理解gtest的后续实践，本系列文章分成前后两个部分，前半部分主要以gtest 所自带的samples([samples in github][1])为例，讲述一下gtest的基本用法。后半部分主要在实际应用中的gtest的用法，以及一些测试感悟，希望不要让大家失望。&lt;/p&gt;

</description>
        
        <pubDate>Thu, 11 Aug 2016 10:18:00 +0000</pubDate>
        <link>
        http://airfer.github.io//gtest-unittest-1</link>
        <guid isPermaLink="true">http://airfer.github.io//gtest-unittest-1</guid>
      </item>
      
    
      
      <item>
        <title>轻量级日志监控框架airMonitor</title>
        
          <description>&lt;h4&gt;一、前言&lt;/h4&gt;

</description>
        
        <pubDate>Tue, 17 May 2016 10:18:00 +0000</pubDate>
        <link>
        http://airfer.github.io//airMonitor</link>
        <guid isPermaLink="true">http://airfer.github.io//airMonitor</guid>
      </item>
      
    
      
      <item>
        <title>广告平台系统架构实现</title>
        
          <description>&lt;h4&gt;前言&lt;/h4&gt;

</description>
        
        <pubDate>Wed, 30 Mar 2016 15:18:00 +0000</pubDate>
        <link>
        http://airfer.github.io//ads-platform</link>
        <guid isPermaLink="true">http://airfer.github.io//ads-platform</guid>
      </item>
      
    
      
      <item>
        <title>支付网关逻辑之网关交易</title>
        
          <description>&lt;h5&gt;前言&lt;/h5&gt;

&lt;p&gt;支付底层服务最难的部分便是根据不同的支付场景进行各种复杂的逻辑记账。不同场景的逻辑记账搞清楚了，那么
整个的底层服务也就清晰明了。这个部分上手也是最难的，常用的方法就是根据底层服务的日志信息进行分析，得到
数据库操作的流程信息，结合这些日志信息以及业务逻辑基础，便可得到支付场景的记账逻辑。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;一、普通的网关交易&lt;/h3&gt;
&lt;p&gt;普通的网关交易，在之前也做过简述。其主要包括两个部分，分别为网关交易注册，类似于购物下单以及网关交易更新，对应用户支付完成
后的操作，现就两种进行分析。&lt;/p&gt;

&lt;p&gt;1、网关注册&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\gateway_register.jpg&quot; alt=&quot;&quot; title=&quot;网关注册图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在网关注册服务中会调起两个服务，分别为&lt;em&gt;GatewayService&lt;/em&gt;以及&lt;em&gt;TransService&lt;/em&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1） GatewayService&lt;/strong&gt; ：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从数据库表中根据&lt;em&gt;user_id&lt;/em&gt;来查询&lt;em&gt;user_id&lt;/em&gt;所对应的账户&lt;em&gt;id&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;查询&lt;em&gt;g_trans_log&lt;/em&gt;网关交易流水表，判断此笔订单是否已经进行了注册&lt;/li&gt;
  &lt;li&gt;如果此笔订单没有进行注册，则调起&lt;em&gt;TransService&lt;/em&gt;进行交易注册&lt;/li&gt;
  &lt;li&gt;交易注册完成后，在&lt;em&gt;g_trans_log&lt;/em&gt;网关交易流水表中，进行注册&lt;/li&gt;
  &lt;li&gt;注册完成后，将结果返回给前端&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（2） TransService&lt;/strong&gt; ：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;查询用户账户&lt;em&gt;id&lt;/em&gt;以及商户账户&lt;em&gt;id&lt;/em&gt;是否可用&lt;/li&gt;
  &lt;li&gt;如果两者账户id可用，则在日常交易表&lt;em&gt;t_trans&lt;/em&gt;中进行登记&lt;/li&gt;
  &lt;li&gt;同时在日常交易流水表&lt;em&gt;t_trans_log&lt;/em&gt;中进行登记&lt;/li&gt;
  &lt;li&gt;最后在收款单&lt;em&gt;t_receivables&lt;/em&gt;中进行注册&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2、网关更新&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\gateway_update.jpg&quot; alt=&quot;&quot; title=&quot;网关更新图&quot; /&gt;&lt;/p&gt;

</description>
        
        <pubDate>Fri, 09 Oct 2015 18:19:00 +0000</pubDate>
        <link>
        http://airfer.github.io//pay-part4</link>
        <guid isPermaLink="true">http://airfer.github.io//pay-part4</guid>
      </item>
      
    
      
      <item>
        <title>支付业务入门及实践</title>
        
          <description>&lt;h4&gt;前言&lt;/h4&gt;

</description>
        
        <pubDate>Tue, 15 Sep 2015 14:18:00 +0000</pubDate>
        <link>
        http://airfer.github.io//begin-to-know-pay-service</link>
        <guid isPermaLink="true">http://airfer.github.io//begin-to-know-pay-service</guid>
      </item>
      
    
      
      <item>
        <title>发布在脉脉上的一些文章</title>
        
          <description>&lt;h4&gt;前言&lt;/h4&gt;

</description>
        
        <pubDate>Tue, 25 Aug 2015 14:18:00 +0000</pubDate>
        <link>
        http://airfer.github.io//articles-published-in-maimai</link>
        <guid isPermaLink="true">http://airfer.github.io//articles-published-in-maimai</guid>
      </item>
      
    
      
      <item>
        <title>支付网关逻辑之特殊场景</title>
        
          <description>&lt;h4&gt;前言&lt;/h4&gt;
&lt;p&gt;在支付的过程中，很多时候会有特殊的场景出现，现有的支付系统必须能够做到对支付的异常状况进行处理。
在这篇文章里，将对一些特殊的情况进行说明。&lt;/p&gt;

</description>
        
        <pubDate>Wed, 12 Aug 2015 18:19:00 +0000</pubDate>
        <link>
        http://airfer.github.io//pay-part3</link>
        <guid isPermaLink="true">http://airfer.github.io//pay-part3</guid>
      </item>
      
    
      
      <item>
        <title>支付网关之场景支付</title>
        
          <description>&lt;h4&gt;前言&lt;/h4&gt;
&lt;p&gt;在了解基本的支付网关逻辑数据库的设计原理之后，就可将所学到的知识用于实际的场景支付测试中
不同的支付场景，支付的逻辑也迥然不同。常见的场景支付有普通的网关交易，如用户在线购物；还有如
商户现金红包派发、优惠券组合支付、个人钱包充值消费退回、优惠券派发等等。不同的支付场景下理解支付的
业务逻辑最为关键，只有理解了业务逻辑，才能更好的明白测试的点在什么地方。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;下面就以普通的网关交易为例子来阐述整个支付逻辑的过程：&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;一、支付逻辑框架图&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;\images\pay1.png&quot; alt=&quot;&quot; title=&quot;支付逻辑框架图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上述图可以很好的将支付从前端到后端的逻辑表述清楚，从图中可以看出整个支付逻辑可以分成三块
用户、商户、支付网关。每个部分都有自己独立的逻辑结构，现就逻辑结构进行分析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用户商户之间：用户在选购完商品，然后在商户服务器生成相关的订单，点击“去支付”后，会跳转到
支付网关的相关相关页面，在这个页面中用户可以选择相关的银行，或者是第三方支付比如支付宝。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;商户与支付网关之间：用户在支付网关完成相关支付，在支付完成后会跳转到商户定义的某个页面（支付
成功或者支付失败的返回页面会不同）。与此同时支付网关服务器会通知商户服务器，这笔订单是否成功，商户
服务器在收到确认通知后，会向支付网关服务器发送一个确认报文，确认收到通知信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：不同的网关支付，其实现方案也是有所差别，有的网关服务器并非在支付完成后向商户服务器发送报文，而是
需要商户服务器主动发送报文请求进行询问，类似于Tcp/Ip协议的三次握手。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;商户与用户之间：商户与用户之间的信息交互是将银行返回的支付结果以一种更加人性化的方式给用户呈现，
支付成功的话，可能会有链接可以使用户点击跳转查看订单详情。如果失败则可能会给用户提示此次支付失败的原因。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二、支付网关注册逻辑图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;\images\gatewayRegister.jpg&quot; alt=&quot;&quot; title=&quot;网关交易注册&quot; /&gt;&lt;/p&gt;

&lt;p&gt;网关交易注册描述的是在支付进行时，支付网关前端与支付网关后台交互的场景。商户服务器将订单的相关信息包括订单号、支付金额等信息发送到支付网关前端，支付网关前端服务器抽取这些信息，并将这些信息组合成交易注册报文发送给网关支付后台服务器。网关支付后台服务器接收到注册报文后将做以下操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先是支付网关服务&lt;em&gt;GatewayServer&lt;/em&gt;接收报文请求信息，并完成分发。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果判断判断这是一笔交易，将会调用&lt;em&gt;TransServer&lt;/em&gt;服务。&lt;em&gt;TtransSer&lt;/em&gt;服务将完成一系列数据表的记账操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后&lt;em&gt;TransServer&lt;/em&gt;服务完成后将重新回到网关&lt;em&gt;GatewayServer&lt;/em&gt;服务处，并完成核心网关的记账操作，最终记账完成。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;三、支付网关更新逻辑图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;\images\gatewayUpdate.jpg&quot; alt=&quot;&quot; title=&quot;网关交易更新&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;网关交易更新&lt;/em&gt;描述的在支付完成后，支付网关前端与支付网关服务器交互的场景。支付网关前端在获知银行返回的支付
结果后，将银行返回的信息包括支付的单号、成功后的银行返回单号等，组成更新报文并将报文发送到支付网关后台
服务器。支付网关后台服务器在完成一系列的记账操作后结束此次交易。网关注册与网关更新有一些区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;信息的来源不同。注册信息来源于商户服务器发送的信息，而更新来源于银行返回的信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据表的更新不同。以网关交易为例，注册的时候并不涉及到账户资金的变动，也就是说tAccounts表中的数据
并不会发生变化，但是在网关交易更新时，会根据银行返回的结果来变更账户的余额信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意的时，每次对交易表、收款表、账户表进行变动的时候都会产生相关的流水变化，便于查账。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;四、总结&lt;/h3&gt;

&lt;p&gt;本章以网关交易注册更新为例，对一般情形下的支付流程进行了简要的总结，在最后一章中将对支付中的一些概念进行整理。&lt;/p&gt;
</description>
        
        <pubDate>Mon, 10 Aug 2015 20:19:00 +0000</pubDate>
        <link>
        http://airfer.github.io//pay-part2</link>
        <guid isPermaLink="true">http://airfer.github.io//pay-part2</guid>
      </item>
      
    
      
      <item>
        <title>支付网关数据库设计之道</title>
        
          <description>&lt;h4&gt;前言&lt;/h4&gt;
&lt;p&gt;在支付业务组已经有很长的时间了，现在可以抽时间将所做的业务逻辑进行梳理一下，也算是总结吧。
接触支付业务以来，感觉支付业务的逻辑很是复杂，上手的时间很慢，现在有一年的时间了，我也不敢说
我对支付业务完全了解了，现就我所知道的部分做个总结吧，本次支付逻辑共有三章内容。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;###一、数据表
数据库中的数据表是整个核心逻辑的载体说在，所有的记账逻辑、以及与支付前台交互的数据都是在这里
进行记录。现就主要的表进行简要说明。不同的第三方支付其数据表名称肯定也不同，这里的表名称仅作参考&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;gTransLog表&lt;/em&gt;&lt;/strong&gt;： 支付网关交易流水表，所有通过网关的交易全部都会在此表中写入数据。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tAccounts表&lt;/em&gt;&lt;/strong&gt;： 用户的账户数据记录表，在第三方系统中其记录着用户的账上资金。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tAccountLog表&lt;/em&gt;&lt;/strong&gt;： 用于记录账户的自己流水情况，所有对tAccounts表的资金变动都会在流水表中进行记录&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tBankPaymentInfo表&lt;/em&gt;&lt;/strong&gt;： 上传对账文件后，解析对账文件生成的表&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tBankcardInfo表&lt;/em&gt;&lt;/strong&gt;： 用于存储用户或者商户所绑定银行卡的信息，包括银行名称、卡号等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tChannelConfig表&lt;/em&gt;&lt;/strong&gt;： 渠道配置表，用于配置商户与不同渠道的对应关系，比如接入支付宝或者招商银行&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tFreeze表&lt;/em&gt;&lt;/strong&gt;： 冻结表，当tAccounts表中的资金有事先冻结的情况下，比如说基金赎回等会向tFreezes表中插入数据&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tPayments表&lt;/em&gt;&lt;/strong&gt;： 付款表，记录账户付款相关信息&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tReceivables表&lt;/em&gt;&lt;/strong&gt;： 收款表，记录收款信息&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tPaymentChannel表&lt;/em&gt;&lt;/strong&gt;:  商户付款渠道的相关信息&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tRefundChannel表&lt;/em&gt;&lt;/strong&gt;： 商户退款屠刀的相关信息&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tRollLog表&lt;/em&gt;&lt;/strong&gt;： 业务流水表&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tTrans表&lt;/em&gt;&lt;/strong&gt;:  交易表,只要是交易，资金有变化，是商户与用户交互的过程&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tTransLog表&lt;/em&gt;&lt;/strong&gt;： 交易流水表，记录交易流水的相关信息&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tTransCashBack&lt;/em&gt;&lt;/strong&gt;： 记录银行账号退款的相关信息&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tBankPayReconFile表&lt;/em&gt;&lt;/strong&gt;：上传对账文件后，解析对账文件生成的表&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tReconcilationPaySucc表&lt;/em&gt;&lt;/strong&gt;：对账成功后写入的表&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tReconcilationPayFail表&lt;/em&gt;&lt;/strong&gt;：对账失败后写入的表&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;tAccountSystemayPaymentInfo表&lt;/em&gt;&lt;/strong&gt;：付款内部数据收集表&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;二、数据表分析&lt;/h3&gt;
&lt;p&gt;在第一部分对其中后台记账系统的数据表中大致进行了一下说明，但是其中也会有一些需要注意的点，
这才测试中分出关键。现在就每一个表进行详细的分析一下。&lt;/p&gt;

&lt;p&gt;1、&lt;strong&gt;&lt;em&gt;gTransLog表&lt;/em&gt;&lt;/strong&gt;：该表是所有网关交易都要登记的表，从支付前台传入的数据首先经过&lt;em&gt;gTransLog&lt;/em&gt;表进行
网关登记和注册，然后再进行其他记账。在表中有内部交易单号，用于查取交易数据；有&lt;em&gt;returnCode&lt;/em&gt;用户存放银行返回
的数据；有状态标志用于查询交易的最终状态。很多时候，支付前端的请求都是直接查取网关表来进行某些交易逻辑判断。&lt;/p&gt;

&lt;p&gt;2、&lt;strong&gt;&lt;em&gt;tAccounts表&lt;/em&gt;&lt;/strong&gt;：该表是账户数据记录表，记录着用户账上的资金。可以联系一下支付宝，就相当于个人的支付宝账户
里面的余额。不同的记账系统对账户的区分也不一样，可能有的账户系统中只用商户账户存在，有的则允许个人和商户都存在。该
表中的账户除了较为重要的&lt;em&gt;Balance Amount&lt;/em&gt;外，还有几点需要注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;账户的冻结金额&lt;/li&gt;
  &lt;li&gt;账户的子类型，有些时候需要关注是主账户还是次级账户&lt;/li&gt;
  &lt;li&gt;账户的科目类型，是资产账户还是负债账户，这在记录账户流水的时候很有用&lt;/li&gt;
  &lt;li&gt;账户的状态，可用还是失效&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3、&lt;strong&gt;&lt;em&gt;tAccountLog表&lt;/em&gt;&lt;/strong&gt;: 该表是用来记录资金账户流水变化，并记录相关交易单号以及金额。在表中会有标志记录这次的资金流动情况
是借记还是贷记，这在核对账户的资金流动上很重要，难免出错。&lt;/p&gt;

&lt;p&gt;4、&lt;strong&gt;&lt;em&gt;tBankPaymentInfo表&lt;/em&gt;&lt;/strong&gt;：这个表在对账的时候使用，关于对账相关逻辑在下一章情景支付中进行讲述。这个表是付款对账表，当然与之
相对的是收款对账表，在此仅以付款对账表进行讲述。将对账文件进行解析，获取文件中数据，来成生成此表。将在外部对账时使用。&lt;/p&gt;

&lt;p&gt;5、&lt;strong&gt;&lt;em&gt;tChannelConfig表&lt;/em&gt;&lt;/strong&gt;：该表是渠道配置表，主要是商户使用。该表中配置了商户以及此商户所接入的渠道，比如支付宝或者某银行。可以
从现实生活中去理解此逻辑，在某商户进行购物时并不是每一个商户都对某家银行支持，说的也是这个道理。&lt;/p&gt;

&lt;p&gt;6、&lt;strong&gt;&lt;em&gt;tFreezes表&lt;/em&gt;&lt;/strong&gt;：该表为冻结表，当有交易发生资金冻结的情况时，都会向这个表中写入数据；而当这个某些资金解冻后，也将该冻结表中的
状态改为解冻。并不是所有的交易在金额变动之前都会去事先冻结金额，对于实时性交易来说，账户的钱是会被实时扣除。账户资金出现冻结的情况
出现在基金申购、优惠券消费等为数不多的场景中。&lt;/p&gt;

&lt;p&gt;7、&lt;strong&gt;&lt;em&gt;tPayments表&lt;/em&gt;&lt;/strong&gt;: 该表为付款表，这里的付款是从商户的角度来说的，对于用户来说就是收款。初次涉及账户逻辑时很容易将这逻辑搞混，这个表使用
再向用户打钱的时候才会被用到。比如在基金赎回的场景中，就会向这个表中插入数据，通过表中的状态，就可以判断其向用户打钱有没有成功，对于没有成功、
的情形又会涉及到退票的情形，这在下一章讨论。&lt;/p&gt;

&lt;p&gt;8、&lt;strong&gt;&lt;em&gt;tReceivables表&lt;/em&gt;&lt;/strong&gt;: 该表为收款表。这里的收款也是对商户而言，对用户而言则是付款。比如用户在进行购物的时候，用户是付款，商户是收款，那么此时
就会向此表中插入数据，其表中也存有&lt;em&gt;state&lt;/em&gt;字段用来表示用户付款有没有成功。只要是涉及用户的资金进入第三方系统，此表都会有收款数据写入。&lt;/p&gt;

&lt;p&gt;9、&lt;strong&gt;&lt;em&gt;tPaymentChannel表&lt;/em&gt;&lt;/strong&gt;:此表为付款渠道表，如果从字面意思进行理解便可知道，这个是付款时的渠道。不管是商户还是用户其相关的付款渠道信息都是在此
配置，如果在这个表中将渠道置为无效，则在支付前端看不到此渠道。&lt;/p&gt;

&lt;p&gt;10、&lt;strong&gt;&lt;em&gt;tRefundChannel表&lt;/em&gt;&lt;/strong&gt;：此表是退款渠道配置表，可以类比付款渠道配置表进行理解。&lt;/p&gt;

&lt;p&gt;11、&lt;strong&gt;&lt;em&gt;tTrans表&lt;/em&gt;&lt;/strong&gt;：该表是交易表，核心点在与交易，交易必须有买和卖，只有这样才能完成交易。此时就涉及一个易被忽视的问题，比如向用户向自己钱包充值，
这个阶段只是收钱，并没有存在交易，所以在这个场景下并不会向该表中写入数据。在一般的交易中，可查看表中的状态来判断此交易的状态，是等待付款、付款完成
、付款失败、已清算。支付前端也时刻通过这个表来进行其他联接查询操作。&lt;/p&gt;

&lt;p&gt;12、&lt;strong&gt;&lt;em&gt;tTransLog表&lt;/em&gt;&lt;/strong&gt;：该表为交易流水表，对tTans表的变化都会在&lt;em&gt;tTransLog&lt;/em&gt;中进行记录，这在后续查询交易异常情况下，比较有帮助作用&lt;/p&gt;

&lt;p&gt;13、&lt;strong&gt;&lt;em&gt;tTransCashBack表&lt;/em&gt;&lt;/strong&gt;：该表为现金退款表，当用户通过银行卡支付并成功扣款后，这个时候如果发起退款那么要这个表中插入数据。有一个情况要注意，这个表中的
数据只涉及银行退款，比如在组合消费的时候，可能有优惠券的金额。那么由于优惠券过期而发生退款时，银行卡退款部分写入&lt;em&gt;tTransCashBack&lt;/em&gt;表中。&lt;/p&gt;

&lt;p&gt;14、&lt;strong&gt;&lt;em&gt;tBankPayReconFile表&lt;/em&gt;&lt;/strong&gt;：这个表中的数据为解析银行付款对账文件而来，其数据来源于银行。这个数据表为付款文件对账表，与之相对的是收款银行文件对账表，虽然
在这里没有将其列出，但是其业务逻辑思想是相通的。&lt;/p&gt;

&lt;p&gt;15、&lt;strong&gt;&lt;em&gt;tReconcilationPaySucc表&lt;/em&gt;&lt;/strong&gt;：对账数据的结果存放处，对账的结果又对平和对差的区别。具体在这里不做讲解，对平的数据放入此表中，而对差的数据放入&lt;em&gt;Fail&lt;/em&gt;表中。&lt;/p&gt;

&lt;p&gt;16、&lt;strong&gt;&lt;em&gt;tAccountSystemayPaymentInfo&lt;/em&gt;&lt;/strong&gt;：这个表为付款信息收集表，也是内部对账后的结果表。与之相对的是收款信息收集表。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;三、总结&lt;/h3&gt;

&lt;p&gt;本章就支付网关系统进行了粗略的介绍，对所设计的表以及表的功能进行了简述，在理解各数据表的基本功能后，其理解各业务场景也就变的相对容易了。&lt;/p&gt;
</description>
        
        <pubDate>Fri, 07 Aug 2015 19:19:00 +0000</pubDate>
        <link>
        http://airfer.github.io//pay-part1</link>
        <guid isPermaLink="true">http://airfer.github.io//pay-part1</guid>
      </item>
      
    
  </channel>
</rss>
