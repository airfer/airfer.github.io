<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>airfer.github.io/</title>
   
   <link>http://airfer.github.io/</link>
   <description>There are some things in this world will never change and some things do change,everything that has a beginning has an end </description>
   <language>en-uk</language>
   <managingEditor> Wang Yukun</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>基于 Docker 的分布式测试系统构建 (二)</title>
	  <link>//pc-ads-distribution-docker</link>
	  <author>Wang Yukun</author>
	  <pubDate>2016-11-06T15:18:00+00:00</pubDate>
	  <guid>//pc-ads-distribution-docker</guid>
	  <description><![CDATA[
	     <p><strong>前言：</strong>
在基于<a href="https://testerhome.com/topics/6184">Docker的分布式测试系统构建（一）</a>中主要阐述了两个方面的内容，分别为开发此分布式测试系统的缘由以及docker基础镜像的构建和踩过的坑。在本篇中主要有4个部分的内容，分别为分布式测试系统的架构、技术实现细节简述、docker Node节点的部署，以及前端实现。</p>

<blockquote>
  <p>—-  搜狗ADTQ测试组出品</p>
</blockquote>

<hr />

<h5>一、分布式测试系统的架构</h5>
<hr />
<p>整体的测试架构主要Docker Nodes节点，Mongodb Broker，Mongodb DB, Front Web，这4个部分构成，其实现的架构简图如下所示：
<img src="/images/pc_ads_distribution/base-framework.jpg" alt="" />
现在就每个部分简要叙述：</p>

<p><em>1. Docker Node节点简述</em>
Docker Node节点主要有Celery 异步框架，Celery Worker任务，Nosetests 测试框架，Mock服务构成。
其分布式实现主要有Celery来完成，通过编写Celery worker 任务来实现具体的测试逻辑。由于业务逻辑本身的需求情况，分层级的调用关系成为实现的有效途径。Celery Worker从Mongodb Broker接收需要完成的任务信息，然后调用Node节点本身的Nosetests框架和Shell脚本，最后调用Mock Service辅助完成测试任务。Celery Worker完成待定的测试任务后，将测试结果写入MongoBD 数据库中以备前端调用。</p>

<p><em>2. Docker Swarm</em>
由于本系统的docker node节点并不多，考虑实现成本以及后续管理难易程度，本系统使用Swarm来管理docker node节点。如果docker node节点众多，可以考虑k8s。关于docker swarm在第二部分会进行说明，这里不在叙述。</p>

<p><em>3. Mogondb</em>
在本系统中，MongoDB主要有两个方面的用途。用途一，作为Celery 的broker，接收前端发送过来的任务请求信息，当broker中有数据时，Celery Worker从broker中获取数据，完成后续任务执行过程；用途二，作为DataBase，Celery worker完成任务后，将result.json数据写入到数据库中</p>

<p><em>4. 前端实现</em>
由于部门内当前的web系统，使用的是Flask Web框架，所以前端主要由Flask + Jquery + Bootstrap实现
整个架构实现还算比较清晰，这对后期的维护也带来了方便。</p>

<h5>二、技术实现有关细节简述</h5>
<hr />

<p><em>1. 关于使用Celery作为异步框架</em>
由于测试用例本身都是基于python来开发的，并且web系统为Flask，所以有充分的理由选择Celery,关于异步框架的选择可以参考<a href="https://testerhome.com/topics/5732">基于 Docker 集群的分布式测试系统 DDT (DockerDistributedTest)</a>文章中对异步框架的对比。</p>

<p><em>2. 关于Nosetests的插件化</em>
默认安装的nosetests是并未安装json插件的，但是提供xml格式。为了便于后续的结果处理，需要事先安装json插件。这里还有一个小插曲，由于之前从来都是使用默认的插件，都不太清楚原来nosetests也可以私自开发插件并安装，走了不少弯路。当然json的插件不需要自己再重复造轮子，可以直接下载安装。</p>

<p>由于nosetests提供了xml格式报告输出，所以第一时间选择的是xml作为最后的结果报文格式。用到–with-xunit参数，同时需要安装nosexunit插件，但是安装的过程中，需要coverage特定版本的支持，为2.85版本。但是即使安装了2.85版本的支持包，<a href="https://pypi.python.org/pypi/coverage/2.85">https://pypi.python.org/pypi/coverage/2.85</a>也同样会报错。</p>

<p>安装后，使用–with-xunit来运行，会提示如下信息：<em>NameError: global name ‘pylint’ is not defined</em>。但是pylint已经被正确安装，出现这个错误很是匪夷所思。后来以为是nosexunit的版本的问题，现在安装的是最新版本0.3.3，后来换成0.3.2和0.3.1都会出现错误，暂时还没有发现原因。所以最后还是使用json作为结果输出格式。</p>

<p><em>3. 关于测试数据以及环境准备</em>
数据更新以及运行相关环境的准备，总体来说可以有两种大的途径，可总结为远程拉取，和本地挂载。</p>

<ul>
  <li>远程拉取</li>
</ul>

<p>远程拉取可以有多种方法，第一种为通过rsync方法，将目的机中的数据远程拉取到docker node中，但是由于运行环境的数据量太大，所以当初认为并不可行。经过统计，在内网中完全拉取大小在5.5G左右的文件夹，需要6分钟左右，这个时间太长了。所以当初这个方案是被废弃了。</p>

<p>第二种方法为使用svn或者git，svn的话对于一些特别大的文件，会提示上传受到限制，这种情况下可以使用svn ignore对某些大的文件进行排除，后来发现由于文件夹太大的原因导致svn报错，使用svn ignore属性同样不能解决问题，现在svn报错也还无法查明原因。</p>

<ul>
  <li>本地挂载</li>
</ul>

<p>通过将所需要的文件传输到docker node宿主机中，然后在运行docker node的时候通过docker -v 本地挂载的形式，可以比较方便的解决环境问题。但是这样会使得部署一个node节点也复杂了一步，必须先同步环境相关数据到docker宿主机，这样又绕回了问题本身。所以本地挂载在本分布式测试系统中并不合适。</p>

<p>所以最后还是要考虑第一个方案。在仔细研究了rsync服务后，发现之前对rsync的研究并不深入，并不清楚rsync的差异性同步模式，通过这篇文章进行了详细的了解，<a href="https://segmentfault.com/a/1190000002427568">https://segmentfault.com/a/1190000002427568</a>，最后决定使用rsync的方式来进行文件同步。
举例如下：</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell">rsync -auvrtzopgP --progress --delete  --exclude <span class="s2">"core.*"</span>   --exclude <span class="s2">"your/log"</span> 192.168.56.73::root/the/des/directory/  ./ </code></pre></figure>

<p>通过设置–exclude 参数可以将不需要同步的文件排除，比如日志文件，这在实践中很有用</p>

<p><em>4. 关于分布式系统的执行粒度</em>
在第一篇文章中我有提，现在的分布式系统执行的最小粒度是文件，也就是说nosetests 在运行测试程序时，最小是全部执行某一个文件中所有的case。比如A.py文件中有10个cases，而B.py文件有50cases，那么运行过程是node1运行A.py中的所有case，node2运行B.py中的所有cases。由于A.py中的cases比较少，所以node1运行完成后，就闲置了。而总的运行时间有node2来决定，这种情况下系统的资源被浪费了。</p>

<p>当以casesID作为执行的基本单元时，这种情况就不复存在了，假如运行一个case为1分钟，那么原先需要运行50min才能运行完所有的case。而在现有的执行粒度下，只需要30min就可以运行完所有的case。关于python文件中casesID的收集，可以通过nosetests –collect-only命令来进行收集。</p>

<p><em>5. 关于Celery worker的命令</em>
由于每一个cases的运行都需要Mock Service的支持，其主程序在内存中只允许运行一个实例，所以每一个docker node节点每次只可以运行一个case，否则便会相互影响。在解决这个问题的时候走了不少弯路，后来在仔细研究了celery worker的命令后，发现可以通过celery worker的运行时参数就可以控制，当时便有一个柳暗花明又一村的感觉。
举例如下：</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell">celery -A pc_ads_distribute_worker worker -c 1 --maxtasksperchild<span class="o">=</span>1 -l INFO</code></pre></figure>

<p>其中的-c参数表示worker并发为1，–maxtasksperchild表示每一个worker最多有几个孩子，同样设置为1，这样就可以满足具体业务测试要求了</p>

<h5>三、docker node节点部署</h5>
<hr />

<p>在已经有了docker 镜像后，需要搭建私有的docker registry来方面docker宿主机更新docker镜像，关于docker 私有registry的搭建可以参考如下的网址，这里不再累述了：</p>

<ul>
  <li>
    <p><a href="https://github.com/docker/distribution/blob/master/docs/index.md">https://github.com/docker/distribution/blob/master/docs/index.md</a></p>
  </li>
  <li>
    <p><a href="https://github.com/docker/docker.github.io/blob/master/registry/index.md">https://github.com/docker/docker.github.io/blob/master/registry/index.md</a></p>
  </li>
  <li>
    <p><a href="http://www.open-open.com/lib/view/open1456539405281.html">http://www.open-open.com/lib/view/open1456539405281.html</a></p>
  </li>
</ul>

<p>关于具体的使用方法示例如下：</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell"><span class="c1">#Images查询地址：</span>
<span class="nb">curl  </span>http://192.168.56.73:5000/v2/_catalog
<span class="c1">#Tags查询：</span>
<span class="nb">curl  </span>http://192.168.56.73:5000/v2/pc/centos6.6_base/tags/list
<span class="c1">#具体使用方法：</span>
docker tag centos6.6:program_auto_v3.6 192.168.56.73:5000/pc/program_auto_v3.6
docker push 192.168.56.73:5000/pc/program_auto_v3.6
docker pull 192.168.56.73:5000/pc/program_auto_v3.6</code></pre></figure>

<p>由于我测试系统中，并未升级到引擎的1.2.1版本，所以需要下载额外的swarm镜像来完成，关于如何通过swarm来管理docker node镜像由于比较简单，就不多写了，有兴趣的可以参考<a href="http://dockone.io/article/227">http://dockone.io/article/227</a>来配置。</p>

<h5>四、前端部分</h5>
<hr />

<p>前端的展示主要有三个部分组成，分别为生成分布式任务、测试任务预览、测试任务统计与查询</p>

<p><em>1. 生成分布式任务及测试任务预览</em>
<img src="/images/pc_ads_distribution/distribute_auto_pic1.jpg" alt="" /></p>

<p>左边栏包含两个主要部分，分别为填写svn的地址以及上传文件。
svn地址为必填，因为分布式测试任务必须要明确是对svn的哪个版本进行的分布式测试；上传文件为可选，如果不上传文件，则运行所有测试用例，如果上传文件，则只运行上传文件中写明的测试用例文件以及确定的caseid，这个功能在只需要运行测试用例集中的某一个子集时比较有用，右边为生成的任务预览模块，每生成一次任务则新增一条记录。</p>

<p><em>2. 任务执行统计</em>
<img src="/images/pc_ads_distribution/distribute_auto_pic2.png" alt="" />
这个图比较清楚就不再说明了</p>

<p><em>3. 具体任务查询</em>
<img src="/images/pc_ads_distribution/distribute_auto_pic3.jpg" alt="" /></p>

<p>可查询某一次具体的执行情况，必须根据运行的成功还是失败，或者根据具体的文件名来查询都可以</p>

<h5>五、结语</h5>
<hr />

<p>这两篇算是对之前所做工作的一个总结吧。一天连写两篇，有种写吐了的感觉，好了，就这样吧，希望对各位童鞋有帮助……</p>


	  ]]></description>
	</item>

	<item>
	  <title>基于 Docker 的分布式测试系统构建 (一)</title>
	  <link>//pc_ads-distribution-prepare-docker</link>
	  <author>Wang Yukun</author>
	  <pubDate>2016-10-25T19:18:00+00:00</pubDate>
	  <guid>//pc_ads-distribution-prepare-docker</guid>
	  <description><![CDATA[
	     <p><strong>前言</strong></p>

<p>关于如何运用docker来解决现实问题并非是一个新鲜的问题，关于docker在测试方面的应用也有很多的文章，本篇是在前人的基础上研究了如何结合业务逻辑构建基于docker的分布式测试系统。当然初次研究肯定有很多不完善的地方，希望抛砖引玉，如果在阅读过程中有什么问题，欢迎大家留言交流。废话不多说了，本系列共2篇6个部分，涵盖了从项目开始到结束的所有基本过程。本篇介绍前2个部分，分别为构建测试系统的需求以及搭建docker镜像，希望本篇文章对你有所帮助。</p>

<blockquote>
  <p>—-  搜狗ADTQ测试组出品</p>
</blockquote>

<hr />

<h5> 一、为何要做这件事 </h5>
<p>现在部门内每次有新的需求上线，都会对之前所有的cases进行回归。cases的数量比较大，每次回归case需要花费很长的时间，部门内现在已有一个分布式的回归工具，是基于Jenkins的api和Shell来做的，虽然实现了基本的分布式的功能，但是也有一些弊端在后续的实践中慢慢显现，主要有以下几个方面：</p>

<ol>
  <li>
    <p><em>case回归的时间很长</em>。case回归的时间长主要有两个方面的原因造成：第一个原因是分布式节点比较少，这使得分布式的优势并没有完全凸显出来；第二个原因是轮询检查子节点的完成情况，并设置超时的时间，超时时间过短则不能完成收集子节点结果的任务，而超时时间过长则进一步延长了case回归的时间</p>
  </li>
  <li>
    <p><em>分布式子节点新增困难</em>。当case量上升，需要新增子节点的时候，发现这并非是一件很容易的事情。由于子节点是jenkins的node节点，所以每次新增节点都相当于部署一个jenkins节点，并需要将任务代码rsync到新的节点中。这对于一个新手来说是很不方便的，不利于后期维护。</p>
  </li>
  <li>
    <p><em>结果展示不够直观</em>。现有的结果展示只有邮件的形式，当运行完成之后通过邮件来通知分布式程序运行的结果，如果你想查看某一个文件中case的执行情况，比如该文件中有多少case成功，或者有多少case失败，抱歉，这并不提供这个功能。你收到的邮件只是一堆失败case的集合。</p>
  </li>
</ol>

<p>当然还有一些其他的弊端，但是主要的问题就是以上的三个方面。后续在解决这三个问题的基础上，也完善了其他的功能，比如case的执行粒度、case的执行情况统计等等。所以在充分调研了现有的分布式工具的基础上，我们提出了新的需求，新需求主要有以下几个方面：</p>

<ul>
  <li>回归case的时间要尽可能的短，最起码要比现有的执行时间短</li>
  <li>case的执行粒度要尽可能的细，现有框架的case是以文件作为最小的执行粒度，而我们要做的是以caseid作为分布调度的基本粒度</li>
  <li>回归结果的展示要更直观，现有的框架仅能够完成失败case的收集并邮件通知，我们要做的是分布式结果收集、统计、展示、查询这四个维度</li>
</ul>

<p>有了需求我们才开始着手新分布式测试工具的开发工作，后续的章节将会从各个方面进行阐述。</p>

<h5>二、构建Docker Images 以及踩过的坑</h5>
<hr />

<p>对于一个刚开始接触docker的新手，一切都是新的，所以就从最开始说起，说说搭建docker镜像的那些事以及踩过的那些坑吧。。。</p>

<p><strong><em>1、搭建基础docker镜像</em></strong></p>

<p><em>Build docker镜像</em>之前，首先要了解的是你的服务程序是运行在哪个linux版本之下的，是Ubuntu还是Redhat或者其他，尽量选择与现有的平台一致的镜像，如果能具体到linux的版本号就最好了。当然如果你说我的程序是通用类型，具体的版本并不重要，那么选择一个你熟悉的镜像就ok了。比如我的服务端程序是运行在redhat6.5下，那么我会选择Centos6.5的版本作为我的基础镜像。</p>

<p>选择与现有平台一致的镜像有利于后续问题的排查，一般你对服务端程序代码的熟悉程度肯定比不了开发，甚至连一知半解都做不到，如果选择不一致的运行平台，如果出现了问题，你可能无法确定是什么原因导致的，是平台？ or 自有的服务端程序? ,而选择一致性平台则排除了这一问题。</p>

<p>服务端程序以c++为例，都会依赖很多的库，而下载下来的镜像是纯净的系统，所以第一步就是按照程序运行的依赖包。如果开发能给出一个依赖包的列表最好，如果不能，那么尝试着运行程序，将缺少的依赖包记录下来，以便制作dockerfile文件。当你尝试着将所有的依赖包安装完整，并且服务端程序可以正常的启动起来，那么dockerfile文件也就差不多制作完成了。</p>

<p>关于dockerfile文件的基础语法我就不再这里详述了，不懂的 搜狗（这是广告，哈哈…）一下吧。下面是我自己制作的dockerfile文件，或许对你有些帮助</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell"><span class="c1"># Dockfile to install bidding module dependency</span>
<span class="c1"># Based on Centos:6.5</span>
 
<span class="k">FROM </span>centos:6.5
 
<span class="c1"># to replace the origin CentOS-Base.repo</span>
WORKDIR /etc/yum.repos.d
RUN <span class="nb">mv </span>CentOS-Base.repo CentOS-Base.repo.backup
 
<span class="c1"># Add new CentOS-Base.repo</span>
ADD CentOS-Base.repo /etc/yum.repos.d/
 
<span class="c1"># Install dependency package</span>
 
RUN yum install gcc g++ gcc-c++
RUN yum install <span class="nb">curl </span>libcurl-devel
RUN yum install boost boost-devel boost-doc
RUN yum instlal zlib zlib-devel
RUN yum install openssl openssl-devel
 
<span class="c1"># Set CXX and CC</span>
 
RUN <span class="nb">echo</span> <span class="s2">"export CC='gcc -std=gnu99'"</span>    &gt;&gt; /etc/profile
RUN <span class="nb">echo</span> <span class="s2">"export CXX='g++ -std=gnu++0x'"</span> &gt;&gt; /etc/profile
 
CMD <span class="o">[</span><span class="s2">"/bin/bash"</span><span class="o">]</span></code></pre></figure>

<p><strong><em>2、从安装docker到构建完镜像踩过的那些坑</em></strong>
从开始接触到后续构建完成，一路走来，跌跌撞撞，幸好问题都已解决，现就碰到的问题与大家分享一下，或许你也正被其中的某一问题所困扰</p>

<p><em>（1）关于docker安装过程中，离线安装的问题（仅限centos系列）:</em>
docker是可以离线安装的，有离线安装包。如果是离线安装则需要按照cgroup依赖包，<a href="http://mirrors.163.com/centos/6/os/x86_64/Packages/">http://mirrors.163.com/centos/6/os/x86_64/Packages/</a>。在这篇文章中写的比较清楚：<a href="http://www.iyunv.com/thread-149007-1-1.html">http://www.iyunv.com/thread-149007-1-1.html</a>，可根据Centos的版本以及安装包依赖，切记不可照搬照抄。如果是可以上外网，最好还是线上安装吧，比如在Ubuntu下，docker的安装一条命令就可以了：
<code class="highlighter-rouge">
curl -sSL https://get.daocloud.io/docker | sh
</code></p>

<p><em>（2）关于centos6下升级docker引擎到1.2.1版本</em>
docker引擎的1.2.1版本集成了新的swarm，所以如果有可能还是使用1.2.1以后版本的docker。但是对于centos6来说，如果要升级到1.2.1版本，则安装的包需要依赖systemd，但Centos6无法安装systemd。</p>

<p>关于这个问题的回答可详细查看：<a href="http://stackoverflow.com/questions/28347694/how-to-install-systemd-on-centos-6-6">http://stackoverflow.com/questions/28347694/how-to-install-systemd-on-centos-6-6</a>，其中在这篇文章说的在Centos6中安装docker-engine1.2.1，会出现依赖包缺失的错误。<a href="http://blog.csdn.net/weiguang1017/article/details/52293235">http://blog.csdn.net/weiguang1017/article/details/52293235</a>，这篇文章也介绍了如何安装，但是我尝试后还是无法在centos6下无法升级到1.2.1以上版本，如果有成功的同学，麻烦告知，谢谢</p>

<p><em>（3）关于修改devicemapper引擎的相关参数（最大的坑）</em>
当你的docker镜像过大时，比如大于10G，那么默认的devicemapper引擎是会报错的，因为docker service初始化的时候，默认分配的存储空间最大也就是10G，所以必须要修改这个参数，并重启docker service。关于修改这个参数，足足搞了一天，差点都放弃了，因为按照网上的资料所有的更改都无法生效，具体方法如下：</p>

<p>第一种方法为service docker start 之前修改，其修改的内容就是增加–storage-opt dm.basesize=30G选项；第二种方法为调用脚本动态增加，具体的操作方法可以参照如下：<a href="http://blog.chinaunix.net/uid-20788636-id-5029770.html">http://blog.chinaunix.net/uid-20788636-id-5029770.html</a>。</p>

<p>先说第二种方法，在运行脚本的过程中，出现以下的错误：<em>resize2fs: Device or resource busy while trying to open /dev/mapper/docker-253:1-1270544-d2d2cef71c86910467c1afdeb79c1a008552f3f9ef9507bb1e04d77f2ad5eac4。</em>因为此脚本主要是调用resize2f函数来进行动态的扩存，但是由于centos6文件格式的为xfs，对比并不支持，所以此方法行不通。对于centos6来说，还可以统统xfs_growfs来进行扩存，但是对比并不熟悉，研究了一些时间，感觉也没有什么头绪，暂时放弃了。关于resize2f调整rootfs可以参照<a href="http://www.111cn.net/sys/linux/87656.htm">http://www.111cn.net/sys/linux/87656.htm</a></p>

<p>但是对于第一种方法，也是会报错，报错的信息如下：<em>Error starting daemon: error initializing graphdriver: Unknown option dm.basesize</em>。所以两种方法现在都无法达到本来预期的目的，当做一些事情的时候，忽然感觉所有的事情都在阻碍你向前进，这个时候应该静下心，努力排查可能出现的错误，找出其中的蛛丝马迹，应该相信你并非是第一个碰到这个题目的人，合理的利用google。经过很久的排查，终于在github的一个issue里面找到了可能存在的问题，该网页如下：<a href="https://github.com/docker/docker/issues/21171">https://github.com/docker/docker/issues/21171</a>。其中的一位同学做了一下的事情：
<img src="/images/docker/answer.png" alt="" /></p>

<p>再指定storage-opt的时候，同时也指定了storage-driver。抱着试一试的心态，添加了上述参数，果然可以成功的改变container中rootfs中的大小，算做经验教训吧。其他有用的选项可参考如下示例：DOCKER_STORAGE_OPTIONS=”–storage-opt dm.loopdatasize=2000G –storage-opt dm.loopmetadatasize=10G –storage-opt dm.fs=ext4 –storage-opt  dm.basesize=20G”</p>

<ul>
  <li>
    <p>dm.loopdatasize=2000G是指存放数据的数据库空间为2t，默认是100g</p>
  </li>
  <li>
    <p>dm.loopmetadatasize=10G是存放Metadata数据空间为10g，默认是2g</p>
  </li>
  <li>
    <p>dm.fs=ext4是指容器磁盘分区为ext4</p>
  </li>
  <li>
    <p>dm.basesize=20G是指容器根分区默认为20g，默认是10g</p>
  </li>
</ul>

<p><em>（4）关于docker镜像拉取以及squid代理</em>
现在很多公司的机子都是内网环境，无法连接外网，无法连接外网也就无法从docker的registry中拉取镜像，除非你们公司搭建了私有的registry并且包含你所需要的镜像。如果没有，那么有两种途经来解决:</p>

<ul>
  <li>
    <p>第一种方法，就是先在可访问外网的机子上（一般个人本机可以访问外网）下载所需要的docker镜像，然后通过docker save命令将其保存为本地镜像，然后导出后再通过docker load 命令将其导入到所需要的docker宿主机中。这种方法比较麻烦，但是好在一般都能实现，对于确实无法连接外网的宿主机也不失为一种办法。</p>
  </li>
  <li>
    <p>第二种办法，就是在内网中找一台可以访问外网的机子，然后在该机子上搭建squid代理服务器，docker的宿主机可以通过配置代理来拉取镜像。关于squlid代理服务器运行可以参照一下命令:</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell">docker run --name squid -d --restart<span class="o">=</span>always <span class="se">\</span>
  --publish 3128:3128 <span class="se">\</span>
  --volume /search/wangyukun/log/cache:/var/spool/squid3 <span class="se">\</span>
  --volume /search/wangyukun/log/squid_log/:/var/log/squid3 <span class="se">\</span>
  sameersbn/squid:3.3.8-19</code></pre></figure>

<p>当然前提是你已经通过第一种方法安装了squid镜像，这属于一次辛苦多次收益，哈哈，如果你们内网的所有自己都无法连接外网，那么只能通过第一种方法了。启动squid代理服务后，那么就要docker宿主机上配置代理服务，以centos6举例，修改/etc/sysconfig/docker 配置文件的内容如下：</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell"><span class="nv">other_args</span><span class="o">=</span><span class="s2">"--graph=/search/odin/wangyukun/docker --insecure-registry 10.142.97.235:5000 --storage-driver devicemapper --storage-opt dm.basesize=100G --storage-opt dm.loopdatasize=2000G --storage-opt dm.loopmetadatasize=10G"</span>
<span class="nv">HTTP_PROXY</span><span class="o">=</span>http://your_squid_service_ip:3128
<span class="nv">http_proxy</span><span class="o">=</span><span class="nv">$HTTP_PROXY</span>
<span class="nv">HTTPS_PROXY</span><span class="o">=</span><span class="nv">$HTTP_PROXY</span>
<span class="nv">https_proxy</span><span class="o">=</span><span class="nv">$HTTP_PROXY</span>
<span class="nb">export </span>HTTP_PROXY HTTPS_PROXY http_proxy https_proxy</code></pre></figure>

<p>这样重启docker service 就可以了。镜像搭建以及走过的坑就先说到这吧，剩下的部分第二篇再续。。。</p>


	  ]]></description>
	</item>


</channel>
</rss>
