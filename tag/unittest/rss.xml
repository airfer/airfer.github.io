<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>airfer.github.io/</title>
   
   <link>http://airfer.github.io/</link>
   <description>There are some things in this world will never change and some things do change,everything that has a beginning has an end </description>
   <language>en-uk</language>
   <managingEditor> Wang Yukun</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>基于 Gtest 的单元测试入门及实践 (二)</title>
	  <link>//gtest-unittest-2</link>
	  <author>Wang Yukun</author>
	  <pubDate>2016-08-12T18:18:00+00:00</pubDate>
	  <guid>//gtest-unittest-2</guid>
	  <description><![CDATA[
	     <p><strong>前言</strong>
在第一章里，主要以gtest自带的samples为例，简单阐述了为普通的成员函数，以及类中的成员函数进行单元测试，在这部分主要介绍如何利用gtest中的固件以及超级固件来优化单元测试工作。在现在的互联网企业对底层模块（C++编写）进行单元测试的并不多见，大家习惯从上层来覆盖底层的功能，这样有好的地方也有不好的地方，这个后续再说吧。本篇文章分成两个部分，第一部分是介绍固件以及超级固件，第二部分是实践以及感悟，如果对第一部分的介绍不感兴趣，可以跳过直接看第二部分</p>

<hr />
<p><strong>一、中级</strong></p>

<ul>
  <li>测试固件   主要包含两个文件，sample3-inl.h 以及 sample3_unittest.cc</li>
</ul>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*sample3-inl.h*/</span>
<span class="cp">#ifndef GTEST_SAMPLES_SAMPLE3_INL_H_
#define GTEST_SAMPLES_SAMPLE3_INL_H_
</span>
<span class="cp">#include &lt;stddef.h&gt;
</span>

<span class="c1">// Queue is a simple queue implemented as a singled-linked list.
// Queue类是一个由单链表构建的队列
// The element type must support copy constructor.
// 队列中的元素必须支持拷贝构造函数
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span>  <span class="c1">// E is the element type
</span><span class="k">class</span> <span class="nc">Queue</span><span class="p">;</span>

<span class="c1">// QueueNode is a node in a Queue, which consists of an element of
// type E and a pointer to the next node.
//
// 队列节点由类型为E的元素，以及指向下一个节点的指针所构成
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span>  <span class="c1">// E is the element type
</span><span class="k">class</span> <span class="nc">QueueNode</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Gets the element in this node.
</span>  <span class="c1">// 获取节点中元素的值
</span>  <span class="k">const</span> <span class="n">E</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">element_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Gets the next node in the queue.
</span>  <span class="c1">// 获取下一个节点
</span>  <span class="n">QueueNode</span><span class="o">*</span> <span class="n">next</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">next_</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">QueueNode</span><span class="o">*</span> <span class="n">next</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">next_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="c1">// Creates a node with a given element value.  The next pointer is
</span>  <span class="c1">// set to NULL.
</span>  <span class="c1">// 对于给定的值生成一个节点，其指向下个节点的指针被设为空
</span>  <span class="k">explicit</span> <span class="n">QueueNode</span><span class="p">(</span><span class="k">const</span> <span class="n">E</span><span class="o">&amp;</span> <span class="n">an_element</span><span class="p">)</span> <span class="o">:</span> <span class="n">element_</span><span class="p">(</span><span class="n">an_element</span><span class="p">),</span> <span class="n">next_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// We disable the default assignment operator and copy c'tor.
</span>  <span class="c1">// 我们将默认的赋值构造函数以及拷贝构造函数设置为无效
</span>  <span class="k">const</span> <span class="n">QueueNode</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">QueueNode</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">QueueNode</span><span class="p">(</span><span class="k">const</span> <span class="n">QueueNode</span><span class="o">&amp;</span><span class="p">);</span>

  <span class="n">E</span> <span class="n">element_</span><span class="p">;</span>
  <span class="n">QueueNode</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">E</span><span class="o">&gt;</span>  <span class="c1">// E is the element type.E是元素的类型
</span><span class="k">class</span> <span class="nc">Queue</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Creates an empty queue.
</span>  <span class="c1">// 生成一个空的队列
</span>  <span class="n">Queue</span><span class="p">()</span> <span class="o">:</span> <span class="n">head_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">last_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">size_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// D'tor.  Clears the queue.
</span>  <span class="o">~</span><span class="n">Queue</span><span class="p">()</span> <span class="p">{</span> <span class="n">Clear</span><span class="p">();</span> <span class="p">}</span>

  <span class="c1">// Clears the queue.
</span>  <span class="c1">// 清空队列
</span>  <span class="kt">void</span> <span class="n">Clear</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 1. Deletes every node.
</span>      <span class="c1">// 删除每一个节点
</span>      <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
      <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">();</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="p">;)</span> <span class="p">{</span>
        <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">();</span>
      <span class="p">}</span>

      <span class="c1">// 2. Resets the member variables.
</span>      <span class="c1">// 重置成员变量
</span>      <span class="n">head_</span> <span class="o">=</span> <span class="n">last_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="n">size_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Gets the number of elements.
</span>  <span class="c1">// 获取队列中元素的数目
</span>  <span class="kt">size_t</span> <span class="n">Size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">size_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Gets the first element of the queue, or NULL if the queue is empty.
</span>  <span class="c1">// 获取队列中的第一个元素，如果队列为空，则返回NULL
</span>  <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">Head</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">head_</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">Head</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">head_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Gets the last element of the queue, or NULL if the queue is empty.
</span>  <span class="c1">// 获取队列中的最后一个元素，如果队列为空，则返回NULL
</span>  <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">Last</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">last_</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">Last</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">last_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Adds an element to the end of the queue.  A copy of the element is
</span>  <span class="c1">// created using the copy constructor, and then stored in the queue.
</span>  <span class="c1">// Changes made to the element in the queue doesn't affect the source
</span>  <span class="c1">// object, and vice versa.
</span>  <span class="c1">//
</span>  <span class="c1">// 向队列的末尾添加一个元素。这个元素由拷贝构造函数生成，并被存储到队列中
</span>  <span class="c1">// 对队列中元素的改变，不会影响到原先的对象，反之亦然
</span>  <span class="kt">void</span> <span class="n">Enqueue</span><span class="p">(</span><span class="k">const</span> <span class="n">E</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">head_</span> <span class="o">=</span> <span class="n">last_</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
      <span class="n">size_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">last_</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
      <span class="n">last_</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
      <span class="n">size_</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Removes the head of the queue and returns it.  Returns NULL if
</span>  <span class="c1">// the queue is empty.
</span>  <span class="c1">// 将队列的头元素移除，并返回它的值，如果为空，则返回NULL
</span>  <span class="n">E</span><span class="o">*</span> <span class="n">Dequeue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="k">const</span> <span class="n">old_head</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span>
    <span class="n">head_</span> <span class="o">=</span> <span class="n">head_</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
    <span class="n">size_</span><span class="o">--</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">last_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">E</span><span class="o">*</span> <span class="n">element</span> <span class="o">=</span> <span class="k">new</span> <span class="n">E</span><span class="p">(</span><span class="n">old_head</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">());</span>
    <span class="k">delete</span> <span class="n">old_head</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">element</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Applies a function/functor on each element of the queue, and
</span>  <span class="c1">// returns the result in a new queue.  The original queue is not
</span>  <span class="c1">// affected.
</span>  <span class="c1">//
</span>  <span class="c1">// 将函数应用于队列中的元素，并将产生的结果存入新的队列中，原始的队列不受影响
</span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
  <span class="n">Queue</span><span class="o">*</span> <span class="n">Map</span><span class="p">(</span><span class="n">F</span> <span class="n">function</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">Queue</span><span class="o">*</span> <span class="n">new_queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head_</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">new_queue</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">new_queue</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">head_</span><span class="p">;</span>  <span class="c1">// The first node of the queue. 队列的头元素
</span>  <span class="n">QueueNode</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;*</span> <span class="n">last_</span><span class="p">;</span>  <span class="c1">// The last node of the queue.  队列的尾元素
</span>  <span class="kt">size_t</span> <span class="n">size_</span><span class="p">;</span>  <span class="c1">// The number of elements in the queue.队列中元素的个数
</span>
  <span class="c1">// We disallow copying a queue.
</span>  <span class="c1">// 我们不允许对队列进行拷贝
</span>  <span class="n">Queue</span><span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#endif  // GTEST_SAMPLES_SAMPLE3_INL_H_</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*sample3_unittest.cc*/</span>
<span class="c1">// In this example, we use a more advanced feature of Google Test called
// test fixture.
//
// A test fixture is a place to hold objects and functions shared by
// all tests in a test case.  Using a test fixture avoids duplicating
// the test code necessary to initialize and cleanup those common
// objects for each test.  It is also useful for defining sub-routines
// that your tests need to invoke a lot.
//
// 在这个例子中，我们将会用到Google Test一个更为高级的特性，被称为测试固件。
// 测试固件的用途主要用于存放所有测试集都要使用的对象或者函数。
//
// 使用测试固件避免了重复一些代码，而这些代码对于初始化或者清除测试用例中
// 的对象又是必须的。同时，测试固件对于定义你测试中需要调起的子例程也很有帮助
// &lt;TechnicalDetails&gt;
//
// The tests share the test fixture in the sense of code sharing, not
// data sharing.  Each test is given its own fresh copy of the
// fixture.  You cannot expect the data modified by one test to be
// passed on to another test, which is a bad idea.
//
// The reason for this design is that tests should be independent and
// repeatable.  In particular, a test should not fail as the result of
// another test's failure.  If one test depends on info produced by
// another test, then the two tests should really be one big test.
//
// The macros for indicating the success/failure of a test
// (EXPECT_TRUE, FAIL, etc) need to know what the current test is
// (when Google Test prints the test result, it tells you which test
// each failure belongs to).  Technically, these macros invoke a
// member function of the Test class.  Therefore, you cannot use them
// in a global function.  That's why you should put test sub-routines
// in a test fixture.
//
//技术细节：
//
//这些测试用例测试固件，在一定意义上是指的代码的共享，和不是数据的共享。
//这样设计的原因是，测试用例应该是独立以及可重复的。特别是当一个测试失败时
//不应该影响其他测试的执行。如果一个测试依赖于另一个测试所产生的结果，那么
//这两个测试应该合并为一个大的测试。
//
//指示测试成功(EXPECT_TRUE)或者失败(EXPECT_FAIL)的宏需要知道当前的测试是那
//一个测试用例(当Goole Test 打印失败的结果时，它告诉你这个失败从属于那个测试),
//从技术的角度来说，这些宏将调用一个Test类的成员函数。因此你不能在全局的函数中
//使用这些宏，这就是你为什么要把测试子例程放入测试固件中的原因。
//
// &lt;/TechnicalDetails&gt;
</span>
<span class="cp">#include "sample3-inl.h"
#include "gtest/gtest.h"
</span>
<span class="c1">// To use a test fixture, derive a class from testing::Test.
// 为了使用测试固件，须从Test类中派生一个类
//
</span><span class="k">class</span> <span class="nc">QueueTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">testing</span><span class="o">::</span><span class="n">Test</span> <span class="p">{</span>
 <span class="k">protected</span><span class="o">:</span>  <span class="c1">// You should make the members protected s.t. they can be
</span>             <span class="c1">// accessed from sub-classes.
</span>             <span class="c1">// 你应该将成员变量声明为保护类型，这样它们将只能被子类访问
</span>
  <span class="c1">// virtual void SetUp() will be called before each test is run.  You
</span>  <span class="c1">// should define it if you need to initialize the varaibles.
</span>  <span class="c1">// Otherwise, this can be skipped.
</span>  <span class="c1">//
</span>  <span class="c1">// 虚函数Setup(),在每一个测试运行之前就被调用，所以如果你需要初始化一些
</span>  <span class="c1">// 变量，你应该在这个地方进行定义，不需要可以跳过
</span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">q1_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">q2_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">q2_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// virtual void TearDown() will be called after each test is run.
</span>  <span class="c1">// You should define it if there is cleanup work to do.  Otherwise,
</span>  <span class="c1">// you don't have to provide it.
</span>  <span class="c1">//
</span>  <span class="c1">// virtual void TearDown() {
</span>  <span class="c1">// }
</span>  <span class="c1">//
</span>  <span class="c1">// 虚函数TearDown()在每一个测试运行之后被调用，如果你需要做一些清理工作
</span>  <span class="c1">// 可以在这个函数中定义。否则你可以忽略它
</span>
  <span class="c1">// A helper function that some test uses.
</span>  <span class="c1">// 帮助函数用于测试
</span>  <span class="k">static</span> <span class="kt">int</span> <span class="n">Double</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// A helper function for testing Queue::Map().
</span>  <span class="c1">// 帮助函数用于测试 Queue::Map()
</span>  <span class="c1">//
</span>  <span class="kt">void</span> <span class="n">MapTester</span><span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Creates a new queue, where each element is twice as big as the
</span>    <span class="c1">// corresponding one in q.
</span>    <span class="c1">// 生成一个新的队列，队列中的元素是原队列元素的两倍
</span>    <span class="k">const</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span> <span class="k">const</span> <span class="n">new_q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">Map</span><span class="p">(</span><span class="n">Double</span><span class="p">);</span>

    <span class="c1">// Verifies that the new queue has the same size as q.
</span>    <span class="c1">// 判断元队列与新队列是否有相同的大小
</span>    <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">(),</span> <span class="n">new_q</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">());</span>

    <span class="c1">// Verifies the relationship between the elements of the two queues.
</span>    <span class="c1">// 验证两个队列中，元素的关系
</span>    <span class="k">for</span> <span class="p">(</span> <span class="k">const</span> <span class="n">QueueNode</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">(),</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">new_q</span><span class="o">-&gt;</span><span class="n">Head</span><span class="p">();</span>
          <span class="n">n1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">n1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">(),</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">n2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n1</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">(),</span> <span class="n">n2</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">delete</span> <span class="n">new_q</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Declares the variables your tests want to use.
</span>  <span class="c1">// 声明测试中需要用到的变量
</span>  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q0_</span><span class="p">;</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q1_</span><span class="p">;</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q2_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// When you have a test fixture, you define a test using TEST_F
// instead of TEST.
// 当你定义了测试固件时，应该使用TEST_F来代替TEST
</span>
<span class="c1">// Tests the default c'tor.
// 测试默认构造函数
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span> <span class="n">DefaultConstructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// You can access data in the test fixture here.
</span>  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span> <span class="n">q0_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// Tests Dequeue().
// 测试出队列
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span> <span class="n">Dequeue</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">q0_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">q1_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span> <span class="n">q1_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
  <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">q2_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1u</span><span class="p">,</span> <span class="n">q2_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
  <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Tests the Queue::Map() function.
// 测试队列中的Map()函数
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span> <span class="n">Map</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MapTester</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0_</span><span class="p">);</span>
  <span class="n">MapTester</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q1_</span><span class="p">);</span>
  <span class="n">MapTester</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q2_</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>测试固件在单元测试中用到的非常多，因为它提供了一种数据共享的方法，同时也保证了各测试用例之间并不会相互影响。例如在本例中，每次在进行测试时，都需要构建测试数据，也就是将数据插入队列中，如果没有测试固件，则需要在每个测试用例中都重复这个操作。</p>

<p>可以看到测试固件的使用简化了单元测试的复杂性，在实际应用中，如果可以使用测试固件就尽量使用测试固件，有一点需要注意的是，如果使用测试固件，则对应的宏应该使用TEST_F,并且第一个参数应该为测试固件的名字。</p>

<ul>
  <li>超级测试固件
本例中主要包含sample1.h,sample1.cc,sample3-inl.h,sample5_unittest.cc</li>
</ul>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*sample5_unittest.cc*/</span>
<span class="c1">// This sample teaches how to reuse a test fixture in multiple test
// cases by deriving sub-fixtures from it.
// 
// 这个例子主要用于展示，如何通过从测试固件中派生子固件，在多重测试中重用
// 测试固件。
//
// When you define a test fixture, you specify the name of the test
// case that will use this fixture.  Therefore, a test fixture can
// be used by only one test case.
//
// 当你定义一个测试固件时，你确定这个使用测试固件的测试用例集的名称，因此
// 一个测试固件只能够被一个测试用例集所使用
//
// Sometimes, more than one test cases may want to use the same or
// slightly different test fixtures.  For example, you may want to
// make sure that all tests for a GUI library don't leak important
// system resources like fonts and brushes.  In Google Test, you do
// this by putting the shared logic in a super (as in "super class")
// test fixture, and then have each test case use a fixture derived
// from this super fixture.
//
// 有些时候，不止一个测试用例集需要使用相同或者有细微差异的测试固件。例如
// 你想确定，针对一个GUI库的所有测试用例集都没有泄漏重要的系统资源，如字体
// 和画刷。在Google Test中，你可以把共享的逻辑放在一个超级测试固件中，然后
// 每一个测试用例集所使用的测试固件都可以从这个超级测试固件类中派生。
</span>
<span class="cp">#include &lt;limits.h&gt;
#include &lt;time.h&gt;
#include "sample3-inl.h"
#include "gtest/gtest.h"
#include "sample1.h"
</span>
<span class="c1">// In this sample, we want to ensure that every test finishes within
// ~5 seconds.  If a test takes longer to run, we consider it a
// failure.
//
// We put the code for timing a test in a test fixture called
// "QuickTest".  QuickTest is intended to be the super fixture that
// other fixtures derive from, therefore there is no test case with
// the name "QuickTest".  This is OK.
//
// Later, we will derive multiple test fixtures from QuickTest.
//
// 在这里例子中，我们需要确保每一个测试都在5s内结束。如果一个测试运行的时间
// 长于5s，我们就认为这个测试失败了
//
// 我们在测试固件中放置计算测试花费时间的代码，并将其称为QuickTest。QuickTest
// 作为超级测试固件而存在，而后续的测试固件都从其派生。所以并没有测试用例集所
// 绑定的测试固件被命名为QuickTest,之后我们将从QuickTest类中派生出多个测试固件
//
</span><span class="k">class</span> <span class="nc">QuickTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">testing</span><span class="o">::</span><span class="n">Test</span> <span class="p">{</span>
 <span class="k">protected</span><span class="o">:</span>
  <span class="c1">// Remember that SetUp() is run immediately before a test starts.
</span>  <span class="c1">// This is a good place to record the start time.
</span>  <span class="c1">// SetUp()函数，在一个测试开始之前执行，所以在其内部可以用来记录开始时间
</span>  <span class="c1">//
</span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">start_time_</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// TearDown() is invoked immediately after a test finishes.  Here we
</span>  <span class="c1">// check if the test was too slow.
</span>  <span class="c1">//
</span>  <span class="c1">// TearDown()函数在一个测试结束之后被调起，所以在这里我们检测一个测试是否太慢
</span>  <span class="c1">//
</span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">TearDown</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Gets the time when the test finishes
</span>    <span class="k">const</span> <span class="kt">time_t</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Asserts that the test took no more than ~5 seconds.  Did you
</span>    <span class="c1">// know that you can use assertions in SetUp() and TearDown() as
</span>    <span class="c1">// well?
</span>    <span class="c1">//
</span>    <span class="c1">// 下面是断言的结果
</span>    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time_</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"The test took too long."</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// The UTC time (in seconds) when the test starts
</span>  <span class="c1">// 超级固件定义的开始时间成员变量
</span>  <span class="kt">time_t</span> <span class="n">start_time_</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// We derive a fixture named IntegerFunctionTest from the QuickTest
// fixture.  All tests using this fixture will be automatically
// required to be quick.
//
// 我们从QuickTest超级固件中派生出一个名为IntergerFunctionTest的测试固件
// 所有使用这个测试固件的测试，都将自动计算测试运行所花费的时间
//
</span><span class="k">class</span> <span class="nc">IntegerFunctionTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QuickTest</span> <span class="p">{</span>
  <span class="c1">// We don't need any more logic than already in the QuickTest fixture.
</span>  <span class="c1">// Therefore the body is empty.
</span>  <span class="c1">// 由于不需要添加新的测试逻辑，所以此函数体为空
</span>  <span class="c1">//
</span><span class="p">};</span>


<span class="c1">// Now we can write tests in the IntegerFunctionTest test case.
// 现在在IntegerFunctionTest测试集中，编写测试用例
//
// Tests Factorial()
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">IntegerFunctionTest</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Tests factorial of negative numbers.
</span>  <span class="c1">//sleep(6);
</span>  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_GT</span><span class="p">(</span><span class="n">Factorial</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// Tests factorial of 0.
</span>  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

  <span class="c1">// Tests factorial of positive numbers.
</span>  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">40320</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>


<span class="c1">// Tests IsPrime()
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">IntegerFunctionTest</span><span class="p">,</span> <span class="n">IsPrime</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Tests negative input.
</span>  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="n">INT_MIN</span><span class="p">));</span>

  <span class="c1">// Tests some trivial cases.
</span>  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>

  <span class="c1">// Tests positive input.
</span>  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">23</span><span class="p">));</span>
<span class="p">}</span>


<span class="c1">// The next test case (named "QueueTest") also needs to be quick, so
// we derive another fixture from QuickTest.
//
// The QueueTest test fixture has some logic and shared objects in
// addition to what's in QuickTest already.  We define the additional
// stuff inside the body of the test fixture, as usual.
//
// 同样，可以从超级固件中派生出另一个测试固件用于队列测试，QueueTest固件
// 还有一些其他的逻辑，以及共享的对象除了计算测试时间之外，所以我们像平常
// 一样在测试固件内部进行定义
//
</span><span class="k">class</span> <span class="nc">QueueTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QuickTest</span> <span class="p">{</span>
 <span class="k">protected</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetUp</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// First, we need to set up the super fixture (QuickTest).
</span>    <span class="c1">// 首先需要调用超级固件的setup，这个地方由于不是指针或者引用调用，所以
</span>    <span class="c1">// 不涉及多态
</span>    <span class="n">QuickTest</span><span class="o">::</span><span class="n">SetUp</span><span class="p">();</span>

    <span class="c1">// Second, some additional setup for this fixture.
</span>    <span class="n">q1_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">q2_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">q2_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// By default, TearDown() inherits the behavior of
</span>  <span class="c1">// QuickTest::TearDown().  As we have no additional cleaning work
</span>  <span class="c1">// for QueueTest, we omit it here.
</span>  <span class="c1">//
</span>  <span class="c1">// 之前已有翻译，这里不再赘述
</span>  <span class="c1">//
</span>  <span class="c1">// virtual void TearDown() {
</span>  <span class="c1">//   QuickTest::TearDown();
</span>  <span class="c1">// }
</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q0_</span><span class="p">;</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q1_</span><span class="p">;</span>
  <span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q2_</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// Now, let's write tests using the QueueTest fixture.
// 现在，让我们使用QueueTest 测试固件来写测试用例
</span>
<span class="c1">// Tests the default constructor.
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span> <span class="n">DefaultConstructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span> <span class="n">q0_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// Tests Dequeue().
</span><span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span> <span class="n">Dequeue</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">q0_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">q1_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span> <span class="n">q1_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
  <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">q2_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1u</span><span class="p">,</span> <span class="n">q2_</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
  <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// If necessary, you can derive further test fixtures from a derived
// fixture itself.  For example, you can derive another fixture from
// QueueTest.  Google Test imposes no limit on how deep the hierarchy
// can be.  In practice, however, you probably don't want it to be too
// deep as to be confusing.
//
// 如果必要的话，你也可以从已派生的固件进行再次派生。例如你可以从QueueTest
// 这个固件中再次派生。GoogleTest对你究竟从中派生多少次并没有限制，但是派生的
</span><span class="o">//</span> <span class="err">层次太深，则容易使人迷惑</span></code></pre></figure>

<p>本例中定义了一个超级固件用来计算测试用例运行的时间，每个需要计算运行时间的测试用例都可以从这个超级固件中派生。把测试固件中的共有特性抽取出来组成超级固件，不管从测试case管理的角度，还是代码的简化都有很好的效果。在实际应用中，测试固件和超级测试固件应用的最多，这并不是说其他的特性不重要，只是我现在还没有用到，关于其他特性大家可以去参考samples中其他sample的介绍。关于Gtest的入门介绍部分就到这了，后面介绍实际应用过程中遇到的问题，以及思考。</p>

<p><strong>二、实践应用以及思考</strong></p>

<p><em>1、如何将Gtest应用到现有的C++工程中？</em></p>

<p>实际的项目工程要比上面两个部分介绍的sample要复杂的多，甚至某些开发都只是负责其中的某一块，对其他的模块可能也知之甚少，如果拿到一个这样的项目要怎么入手是刚开始碰到的第一个难题。</p>

<p>首先如果这个大的项目可以拆分成一个一个独立的模块，各模块之间的联系是通过RPC或者单纯的套接字来交互，那么可以按照模块的方式来分别进行单元测试。如果无法进行拆分，其左右一个整体而存在，或者即使可以拆分成模块，但是这个模块对于单元测试还是太大，这个时候可能就需要从整体来考虑，按照以下的步骤进行：</p>

<ul>
  <li>
    <p>要对整体或者模块的Makefile文件非常的熟悉，因为只有这样，才能明白整体或者模块的文件依赖关系，才能知道哪些是可以拆分出来，哪些不可以。</p>
  </li>
  <li>
    <p>判断是否需要自定义main()函数，如果需要在main()函数中进行一些全局变量的声明或者其他的操作，那么可需要自定义main函数，如果不需要则可使用gtest自带的main函数</p>
  </li>
  <li>
    <p>如果使用将整体或者模块的main()函数，那么将main()函数中所有的内容清空，或者删除原有的Main文件，重新新建一个文件，并编写main函数。需要注意的是，如果是自己新建包含main()函数的文件，那么相应的makefile文件也需要进行改变，否则无法编译通过</p>
  </li>
  <li>
    <p>链接gtest静态库，在上述的例子中每次gtest.a和gtest_main.a都是重新生成，在实际应用中，可以事先将静态库生成，然后在makefile中进行链接。在之前强调过一次，如果使用自定义的main函数，那么链接的是gtest.a静态库，否则链接的是gtest_main.a静态库</p>
  </li>
  <li>
    <p>最后一步就是make 并运行</p>
  </li>
</ul>

<p><em>思考</em>：其实在整个单元测试实践的过程中，这一步是最难的。因为需要对整个项目或者模块都比较了解，特别是需要对原有的makefile文件非常的熟悉。有些时候工程特别大，makefile文件不止一个，可能会在公有的makefile文件中，调用子模块的makefile文件，这个时候就需要有耐心把makefile中的调用关系理清楚，然后在合适的地方添加静态链接库。有些makefile中包含了很多并不常用的特性，比如makefile的命令前缀、makefile的条件判断、makefile中的字符串函数等等可能都需要有一定的了解。如果不熟悉的童鞋，可以点击<a href="http://www.cnblogs.com/wang_yb/p/3990952.html">makefile学习</a>链接事先学习一下。</p>

<p><em>2、对模块依赖以及函数依赖的思考</em></p>

<p>如果测试某一个模块，或者函数，那么首先需要做的就是熟悉特测试的模块或者文件。熟悉的过程是编写单元测试用例的前提条件，如果原有的代码都不熟悉，那么单元测试更是无从谈起了。这个时候才开始真正单元测试的编写过程，但是又有一个问题出现了，模块依赖或者函数依赖。</p>

<p>当真正的开始编写时就会发现，gtest示例中所带的samples都是在非常理想的情况下，也就是说函数或者模块依赖关系很少或者根本就不存在依赖关系，这种情况下编写最简单，samples示例就是例子。但是在现实的项目或者模块中，会发现，即使已经将原有的代码拆分成模块，但是模块内部的依赖关系也非常的复杂。可能一个函数依赖模块中80%的代码（极端的情况下），模块中的代码高度耦合。</p>

<p>在这种高耦合模块中，如果将待测函数代码所在的文件提出来，添加单元测试框架真的是一项很费力的活，需要花费很多时间。这是由于框架中各个文件的依赖关于特别复杂，所以很难直接抽取出这一个文件，因为如果只抽取一个文件，运行过程中可能调用多个别的文件中的数据，这样很难将工程按照模块单独独立出来测试。</p>

<p>解决的办法有两种:</p>

<ul>
  <li>
    <p>如果模块耦合度虽然较高，但是也不至于到极端的情况，比如依赖模块小于30%的代码，这个时候可以将所依赖的文件单独抽取出来，重新根据这些文件构造新的makefile文件，这种情况下工作量也是很大的</p>
  </li>
  <li>
    <p>模块之间的耦合度特别高，超过50%。那么这个时候就不要考虑单独抽取了，依赖原先的makefile文件吧，从整体来进行测试</p>
  </li>
</ul>

<p><em>3、依赖关系的Mock实现</em></p>

<p>关于依赖关系的Mock，每个人都有自己的理解。很多人认为只有对外部资源比如数据库、缓存等的Mock才算是真正的Mock，或者说类似GoogleMock的用法才是正统的mock方法。这么说可能也没有错，因为每个人的理解不同，但是我理解的Mock并不仅限于对外部资源，或者通过googleMock来实现，并且googleMock的应用范围也是有局限的，需要配合虚函数和类继承来完成。关于googleMock的用法并不在本次论述之内，有兴趣的大家可以自己找来看一下。</p>

<p>在测试实践中，更多的是依赖于工程项目或者模块原有的代码来进行mock封装，解决依赖关系
以下面的代码举个例子吧</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include "../src/BiddingHeaders.h"
#include "Constant.h"
</span> 
<span class="c1">//定义文件读取及解析类
</span><span class="k">class</span> <span class="nc">DataConfig</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
            <span class="n">DataLoader</span><span class="o">*</span> <span class="n">data_loader_</span><span class="p">;</span>
            <span class="n">DataCenter</span><span class="o">*</span> <span class="n">instance_ptr</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">load_data_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">file</span><span class="p">);</span>
            <span class="c1">//construct function
</span>            <span class="n">DataConfig</span><span class="p">();</span>
<span class="p">};</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*
 * DataConfig.cpp
 */</span>
<span class="cp">#include "BiddingHeaders.h"
#include "DataConfig.h"
</span> 
<span class="n">DataConfig</span><span class="o">::</span><span class="n">DataConfig</span><span class="p">(){</span>
	<span class="c1">//DataCenter中定义了标签所对应的函数
</span>    <span class="n">instance_ptr</span><span class="o">=</span> <span class="n">DataCenter</span><span class="o">::</span><span class="n">instance</span><span class="p">();</span>
    <span class="n">data_loader_</span><span class="o">=</span><span class="n">instance_ptr</span><span class="o">-&gt;</span><span class="n">get_data_loader</span><span class="p">();</span>
<span class="p">}</span>
 
<span class="c1">//set to default value
</span> 
<span class="kt">int</span> <span class="n">DataConfig</span><span class="o">::</span><span class="n">load_data_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>   
        <span class="n">LOG_ERROR</span><span class="p">(</span><span class="s">"[DataCenter][load_data_file] file name null"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> 
    <span class="p">}</span>   
	
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span> <span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>   
        <span class="n">LOG_ERROR</span><span class="p">(</span><span class="s">"[DataCenter][load_data_file] error to open file: %s"</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> 
    <span class="p">}</span>  
	
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MSG_BUF_LEN</span> <span class="o">*</span> <span class="mi">200</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="c1">// 对相应的标签注册响应函数，比如文件中有A标签，那么会调用DataCenter函数中change_A函数
</span>    <span class="n">data_loader_</span><span class="o">-&gt;</span><span class="n">register_op</span><span class="p">(</span><span class="s">"A"</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DataLoader</span><span class="o">::</span><span class="n">DATA_OP_FUNC</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DataCenter</span><span class="o">::</span><span class="n">change_A</span><span class="p">));</span>
    <span class="n">data_loader_</span><span class="o">-&gt;</span><span class="n">register_op</span><span class="p">(</span><span class="s">"B"</span><span class="p">,</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DataLoader</span><span class="o">::</span><span class="n">DATA_OP_FUNC</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DataCenter</span><span class="o">::</span><span class="n">change_B</span><span class="p">));</span>
    <span class="n">data_loader_</span><span class="o">-&gt;</span><span class="n">register_op</span><span class="p">(</span><span class="s">"C"</span><span class="p">,</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DataLoader</span><span class="o">::</span><span class="n">DATA_OP_FUNC</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DataCenter</span><span class="o">::</span><span class="n">change_C</span><span class="p">));</span>
 
    <span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">fp</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LOG_WARNING</span><span class="p">(</span><span class="s">"[DataCenter][load_data_file] message too long"</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 
	<span class="c1">//process_msg函数用于读取标签标记文档，并调用相对应的函数
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">data_loader_</span><span class="o">-&gt;</span><span class="n">process_msg</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">num</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="n">LOG_INFO</span><span class="p">(</span><span class="s">"[DataCenter][load_data_file] num: %d"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>上述代码中调用了两个类，data_loader类，以及DataCenter类，data_loader作为类成员变量从属于DataCenter类，该代码的作用是处理文本，并根据文本中的标签，调用相关的处理函数。其中data_loader类和DataCenter类为原有项目的文件，其相关的头文件包含在名为BiddingHeaders.h的文件中。</p>

<p>现在假设需要测试的模块，依赖于DataCenter::change_A,那么如何解决呢？</p>

<ul>
  <li>
    <p>如果DataCenter的文件，依赖关系比较简单，可以直接将change_A函数抽取出来，并重新封装成一个文件供调用。</p>
  </li>
  <li>
    <p>如果change_A函数的依赖关系比较复杂，比如需要依赖DataCenter中某些全局的Hash，或者公有模块，那么单独将某一个函数抽取出来就并不合适，这时可以考虑直接依赖整个DataCenter文件，而不是进行单独函数的抽取，来完成单元测试</p>
  </li>
  <li>
    <p>如果是依赖整个DataCenter文件，那么又有一个问题出现，现有的通过data_loader来调用DataCenter中的change_A函数是无法成功的，原因是change_A在DataCenter中为私有成员变量，无法在外部被调用。源代码之所以可以成功，因为data_loader本身就作为DataCenter的成员变量，所以可以调用change_A函数，那么问题又来了，如果在外部成功的调用change_A函数呢？</p>
  </li>
</ul>

<p>对于私有成员变量的调用也是有响应的解决办法，总体来说分为侵入式和非侵入式两种，如下所示:</p>

<ul>
  <li>
    <p>对于侵入式，也就是需要添加响应的代码到源文件中，声明现有的类为DataCenter的友元类(friend),这样便可以访问私有成员。由于需要改动在原先的代码中进行改动，破坏了原有的完整性，并且不利于持续集成，所以我个人并不推荐侵入式方式</p>
  </li>
  <li>
    <p>对于非侵入式，其实这个比起侵入式要简单很多，需要通过shell或者python脚本，将原有的private成员修改为public成员即可。虽然对原有的代码有改动，但是只是改动成员函数的属性，并无代码添加，所以个人推荐这种方式</p>
  </li>
</ul>

<p><em>思考</em>：这样我们就构建起了一个Mock的实现，利用的是原有模块程序的代码。可能有童鞋觉得这样也是很复杂的。确实这样做也比较复杂，但是相对于直接根据待测的模块构建依赖关系要简单的多。如果不这样做，如何构建依赖关系呢？首先change_A的功能，是根据文本的标签，向全局的某hash表中插入相对应标签的数据，那么我们先是要构造需要插入hash表的数据，如果这个数据比较简单还好一些，如果需要插入hash表的数据非常负责，那么单单构建数据这一步，就已经花费了大量的时间。其次，自己编写insert函数，将构造的数据插入hash表中，每次处理不同的标签，都要分别编写不同的函数。其实这相当于把DataCenter原有的功能又简化的重新实现了一遍，这样做的时间成本实在是太大了，两者相比，取其轻！所以最大的利用现有的代码数据，构造mock实例，是一种相对高效的做法。</p>

<p>上述所说是Mock的一种情况，那就是所测单元高度依赖全局的变量，比如例子中的全局hash。那么如果所测模块对全局变量依赖较低，但是依赖的范围比较广呢？比如某一个模块可能依赖多个类。这种情况下，可以直接构建这些类的实例，通过编写set_X函数，对类中的成员变量进行赋值，这在所依赖的类耦合度不高的情况下还是比较有效的，但是如果所依赖的类耦合度较高，类之间关联性明显，则需要根据特定的情况进行分析，并非使用set_X函数就可以解决，这样只能具体问题具体分析了。</p>

<p><em>4、杂谈</em></p>

<p><em>（1）运行和调试</em></p>

<p>当完成单元测试的编写，后面就是运行调试的阶段。没有人可以保证写的单元测试每次不调试都可正常运行，出错是很正常的。其实对于错误的调试方法，和普通的C++程序基本相同。如果在项目本身日志比较完善的情况下，可以通过日志来排查错误；其次，可以在makefile编译的时候添加-g选项，通过gdb调试器来单步执行调试，gdb调试是非常高效的，也是我最长使用的工具，对gdb不熟悉的同学可以了解一下。</p>

<p>在运行过程中，可能会出现Segment fault，这种情况下要重点检查，字符串数组是否越界，是否存在空指针。数组越界和空指针是碰到最多的情况。</p>

<p><em>（2）检测点</em></p>

<p>单元测试，并非只是验证函数或者模块的正常功能是否可以走通，更多的是验证异常情况，验证代码的异常执行路径。如果只是检测函数的正常功能，完全可以通过更高层次来验证，没必要从底层来验证。其实这和接口类测试有些相似，如果只是验证接口的正常功能，从web端或手机端就可以完成验证过程，为什么非要进行接口测试呢？其功能主要都是验证异常的情况，编写测试用例时，异常的情况一定要考虑充足。可能有童鞋会问，怎么样才算考虑充足呢？就是让你的测试用例集覆盖函数的所有执行路径，在测试过程中，结合lcov代码覆盖率检查工具，可以让你清楚的知道，你现在编写的单元测试代码覆盖了哪些路径，这两者的搭配绝对是最佳的搭档</p>

<p><em>（3）适应性</em></p>

<p>对于一些高耦合度项目或者模块，可能并不适合进行单元测试。自己应该对可进行单元测试的模块或者代码有一个清晰的认识，不能为了单元测试而进行单元测试。一般偏基础类的服务是适合做单元测试的，偏业务类的可能会不太适合，自己要做好判断，免得事倍功半。相对于实现的成本来说，上次的功能自动化测试的实现成本相比于单元测试要容易很多，所以如果可以从功能自动化进行覆盖，就没有必要再进行单元测试。具体是否适合还要自己根据项目需求进行判断</p>

<p><em>（4）整合</em></p>

<p>我们希望每次代码有更新的时候，就会进行一次单元测试，并输出相关的测试报告。gtest的输出报告支持普通的文本，以及xml格式。将gtest与Jenkins进行结合，并整合lcov代码覆盖检查，这样每次有新的代码提交都会运行，并输出测试报告，这对于测试人员查看报告是非常方便的，下面是我这边所做的截图：
<img src="/images/unittest/3.png" alt="" /></p>

<p><strong>后记：</strong>
	单元测试的内容还是太多，我也就算刚入门，需要学习的东西还有很多，上面算是初做单元测试的感悟吧，希望对有需要的同学有所帮助，同时也欢迎c++单元测试高手交流经验~</p>


	  ]]></description>
	</item>

	<item>
	  <title>基于 Gtest 的单元测试入门及实践 (一)</title>
	  <link>//gtest-unittest-1</link>
	  <author>Wang Yukun</author>
	  <pubDate>2016-08-11T10:18:00+00:00</pubDate>
	  <guid>//gtest-unittest-1</guid>
	  <description><![CDATA[
	     <h5>前言:</h5>
<p>其实这并不是关于Gtest学习入门的资料，我希望读者在读这篇文件之前还是要对Googletest的单元测试框架有所了解。为了让读者比较容易理解gtest的后续实践，本系列文章分成前后两个部分，前半部分主要以gtest 所自带的samples(<a href="https://github.com/google/googletest/tree/master/googletest/samples">samples in github</a>)为例，讲述一下gtest的基本用法。后半部分主要在实际应用中的gtest的用法，以及一些测试感悟，希望不要让大家失望。</p>

<hr />

<h5>一、初级</h5>

<ul>
  <li>例一
主要来讲述普通函数的单元测试，主要包含3个文件，分别为sample1.h, sample1.cc , sample1_unittest.cc</li>
</ul>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*sample1.h*/</span>
<span class="cp">#ifndef GTEST_SAMPLES_SAMPLE1_H_
#define GTEST_SAMPLES_SAMPLE1_H_
</span>
<span class="c1">// Returns n! (the factorial of n).  For negative n, n! is defined to be 1.
// 求N的阶乘
</span><span class="kt">int</span> <span class="n">Factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="c1">// Returns true iff n is a prime number.
// 判断一个数是否为质数
</span><span class="n">bool</span> <span class="n">IsPrime</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

<span class="cp">#endif  // GTEST_SAMPLES_SAMPLE1_H_</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*samples1.cc*/</span>
<span class="cp">#include "sample1.h"
</span>
<span class="c1">// Returns n! (the factorial of n).  For negative n, n! is defined to be 1.
</span><span class="kt">int</span> <span class="nf">Factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">*=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Returns true iff n is a prime number.
</span><span class="n">bool</span> <span class="nf">IsPrime</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Trivial case 1: small numbers
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// Trivial case 2: even numbers
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span>

  <span class="c1">// Now, we have that n is odd and n &gt;= 3.
</span>
  <span class="c1">// Try to divide n by every odd number i, starting from 3
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// We only have to try i up to the squre root of n
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">/</span><span class="n">i</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

    <span class="c1">// Now, we have i &lt;= n/i &lt; n.
</span>    <span class="c1">// If n is divisible by i, n is not prime.
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// n has no integer factor in the range (1, n), and thus is prime.
</span>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*sample1_unittest.cc*/</span>
<span class="c1">// This sample shows how to write a simple unit test for a function,
// using Google C++ testing framework.
// 这个例子展示了如何使用C++ 单元测试框架对函数进行单元测试
// Writing a unit test using Google C++ testing framework is easy as 1-2-3:
// 利用Google C++单元测试框架做单元测试只须简单的三步
</span>
<span class="c1">// Step 1. Include necessary header files such that the stuff your
// test logic needs is declared.
//
// 第一步，包含必要的头部文件，确保测试逻辑所需要的头文件已被声明，并且不要忘记
// gtest.h。
// Don't forget gtest.h, which declares the testing framework.
</span>
<span class="cp">#include &lt;limits.h&gt;
#include "sample1.h"
#include "gtest/gtest.h"
</span>

<span class="c1">// Step 2. Use the TEST macro to define your tests.
//
// TEST has two parameters: the test case name and the test name.
// After using the macro, you should define your test logic between a
// pair of braces.  You can use a bunch of macros to indicate the
// success or failure of a test.  EXPECT_TRUE and EXPECT_EQ are
// examples of such macros.  For a complete list, see gtest.h.
//
//第二步，TEST宏有两个参数，分别为测试用例集名称和测试用例名称，在使用这个宏以后，
//你需要在{}内定义你的测试逻辑。你可以使用一系列的宏来表示测试的成功或着失败。例如
//EXPECT_TRUE表示期望值正确，EXPECT_EQ表示结果值大于或等于期望值。
//
//
//
// &lt;TechnicalDetails&gt;
//
// In Google Test, tests are grouped into test cases.  This is how we
// keep test code organized.  You should put logically related tests
// into the same test case.
//
// The test case name and the test name should both be valid C++
// identifiers.  And you should not use underscore (_) in the names.
//
// Google Test guarantees that each test you define is run exactly
// once, but it makes no guarantee on the order the tests are
// executed.  Therefore, you should write your tests in such a way
// that their results don't depend on their order.
//
//技术细节：
//    在Google Test中，测试用例被分成测试用例集，这保证了我们的代码有良好的组织性，所以
//你应该把逻辑相关的测试用例归集到同一测试用例集当中。
//
//测试用例集名称以及测试用例名称必须是C++合法的标识符，并且在名称中不允许使用下划线（_）
//Google Test测试框架，可以保证所有定义的测试都能够被正确执行，但是对测试执行的顺序比如先执行那些
//后执行那些并没有保证。所以你编写的测试代码，其测试结果不应该依赖于其执行顺序。
//
// &lt;/TechnicalDetails&gt;
</span>

<span class="c1">// Tests Factorial().
</span>
<span class="c1">// Tests factorial of negative numbers.
// 测试负数的阶乘
</span><span class="n">TEST</span><span class="p">(</span><span class="n">FactorialTest</span><span class="p">,</span> <span class="n">Negative</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// This test is named "Negative", and belongs to the "FactorialTest"
</span>  <span class="c1">// 测试用例集的名称是 FactorialTest, 测试用例名称 是 Negative
</span>  <span class="c1">// test case.
</span>  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_GT</span><span class="p">(</span><span class="n">Factorial</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// &lt;TechnicalDetails&gt;
</span>  <span class="c1">//
</span>  <span class="c1">// EXPECT_EQ(expected, actual) is the same as
</span>  <span class="c1">//
</span>  <span class="c1">//   EXPECT_TRUE((expected) == (actual))
</span>  <span class="c1">//
</span>  <span class="c1">// except that it will print both the expected value and the actual
</span>  <span class="c1">// value when the assertion fails.  This is very helpful for
</span>  <span class="c1">// debugging.  Therefore in this case EXPECT_EQ is preferred.
</span>  <span class="c1">//
</span>  <span class="c1">// On the other hand, EXPECT_TRUE accepts any Boolean expression,
</span>  <span class="c1">// and is thus more general.
</span>  <span class="c1">//
</span>  <span class="c1">//技术细节：
</span>  <span class="c1">//    EXPECT_EQ(expected,actual)与EXPECT_TRUE((expected)==(actual))是等同的，有一点
</span>  <span class="c1">//不同的是，当EXPECT_EQ(expected,actual)失败时会打印出期望的值与实际的值，这对调试非常有帮助，因此使用EXPECT_EQ更好一些。
</span>  <span class="c1">//
</span>  <span class="c1">//但是从另一方面说，由于EXPECT_TRUE可以接受任何类型的布尔表达式，所以应用更广一些
</span>  <span class="c1">//
</span>  <span class="c1">// &lt;/TechnicalDetails&gt;
</span><span class="p">}</span>

<span class="c1">// Tests factorial of 0.
</span><span class="n">TEST</span><span class="p">(</span><span class="n">FactorialTest</span><span class="p">,</span> <span class="n">Zero</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Tests factorial of positive numbers.
</span><span class="n">TEST</span><span class="p">(</span><span class="n">FactorialTest</span><span class="p">,</span> <span class="n">Positive</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">40320</span><span class="p">,</span> <span class="n">Factorial</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>
<span class="p">}</span>


<span class="c1">// Tests IsPrime()
</span>
<span class="c1">// Tests negative input.
</span><span class="n">TEST</span><span class="p">(</span><span class="n">IsPrimeTest</span><span class="p">,</span> <span class="n">Negative</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// This test belongs to the IsPrimeTest test case.
</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="n">INT_MIN</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Tests some trivial cases.
</span><span class="n">TEST</span><span class="p">(</span><span class="n">IsPrimeTest</span><span class="p">,</span> <span class="n">Trivial</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Tests positive input.
</span><span class="n">TEST</span><span class="p">(</span><span class="n">IsPrimeTest</span><span class="p">,</span> <span class="n">Positive</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
  <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
  <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="mi">23</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Step 3. Call RUN_ALL_TESTS() in main().
//
// We do this by linking in src/gtest_main.cc file, which consists of
// a main() function which calls RUN_ALL_TESTS() for us.
//
// This runs all the tests you've defined, prints the result, and
// returns 0 if successful, or 1 otherwise.
//
// Did you notice that we didn't register the tests?  The
// RUN_ALL_TESTS() macro magically knows about all the tests we
// defined.  Isn't this convenient?
//
// 第三步，我们在编译的时候会链接src/gtest_main.cc 文件，这个文件包含了
// main()函数，在main()函数里调用RUN_ALL_TESTS(), 而此函数会调用我们所定义
// 的所有TEST（）函数，并打印运行结果，返回值为0表示成功，为1表示失败。
//
// 由于我们不许要注册这些测试，RUN_ALL_TESTS()就全部替我们做好，所以此框架
</span><span class="o">//</span> <span class="err">使用起来非常的方便。</span></code></pre></figure>

<p>例一中主要阐述了如何根据gtest来编写一个简单的单元测试。关于一些注意事项在技术细节中已经阐述清楚，这样看来单元测试不难吧^^。有一点需要多注意一些，在上文中也提到了，测试用例集与测试用例的关系，在实际测试中，尽量将相关的测试用例放在一个测试用例集里面，这样方便管理，如果出现问题，定位以及调试问题都比较方便。</p>

<p>可以看到，我们本例子，我们并没有添加main函数，在第三步的论述中也阐明了原因。但是如果我们的程序中存在main函数，那么在链接的时候就不要去链接gest_main.cc文件，否则会报错.</p>

<figure class="highlight"><pre><code class="language-powershell" data-lang="powershell"><span class="c1">#makefile文件部分</span>
gtest-all.o : <span class="k">$(</span>GTEST_SRCS_<span class="k">)</span>
	<span class="k">$(</span>CXX<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> -I<span class="k">$(</span>GTEST_DIR<span class="k">)</span> <span class="k">$(</span>CXXFLAGS<span class="k">)</span> -c <span class="se">\</span>
            <span class="k">$(</span>GTEST_DIR<span class="k">)</span>/src/gtest-all.cc

gtest_main.o : <span class="k">$(</span>GTEST_SRCS_<span class="k">)</span>
	<span class="k">$(</span>CXX<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> -I<span class="k">$(</span>GTEST_DIR<span class="k">)</span> <span class="k">$(</span>CXXFLAGS<span class="k">)</span> -c <span class="se">\</span>
            <span class="k">$(</span>GTEST_DIR<span class="k">)</span>/src/gtest_main.cc

gtest.a : gtest-all.o
	<span class="k">$(</span>AR<span class="k">)</span> <span class="k">$(</span>ARFLAGS<span class="k">)</span> <span class="nv">$@</span> <span class="nv">$^</span>

gtest_main.a : gtest-all.o gtest_main.o
	<span class="k">$(</span>AR<span class="k">)</span> <span class="k">$(</span>ARFLAGS<span class="k">)</span> <span class="nv">$@</span> <span class="nv">$^</span>

<span class="c1"># Builds a sample test.  A test should link with either gtest.a or</span>
<span class="c1"># gtest_main.a, depending on whether it defines its own main()</span>
<span class="c1"># function.</span>

sample1.o : <span class="k">$(</span>USER_DIR<span class="k">)</span>/sample1.cc <span class="k">$(</span>USER_DIR<span class="k">)</span>/sample1.h <span class="k">$(</span>GTEST_HEADERS<span class="k">)</span>
	<span class="k">$(</span>CXX<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> <span class="k">$(</span>CXXFLAGS<span class="k">)</span> -c <span class="k">$(</span>USER_DIR<span class="k">)</span>/sample1.cc

sample1_unittest.o : <span class="k">$(</span>USER_DIR<span class="k">)</span>/sample1_unittest.cc <span class="se">\</span>
                     <span class="k">$(</span>USER_DIR<span class="k">)</span>/sample1.h <span class="k">$(</span>GTEST_HEADERS<span class="k">)</span>
	<span class="k">$(</span>CXX<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> <span class="k">$(</span>CXXFLAGS<span class="k">)</span> -c <span class="k">$(</span>USER_DIR<span class="k">)</span>/sample1_unittest.cc

sample1_unittest : sample1.o sample1_unittest.o gtest_main.a
	<span class="k">$(</span>CXX<span class="k">)</span> <span class="k">$(</span>CPPFLAGS<span class="k">)</span> <span class="k">$(</span>CXXFLAGS<span class="k">)</span> -lpthread <span class="nv">$^</span> -o <span class="nv">$@</span></code></pre></figure>

<p>从上述makefile文件的最后看到，在链接生成sample1_unittest可执行文件的时候，链接的是gtest_main.a的静态链接库。如果我们的自定义程序中包含main函数，那么这个地方就需要链接gtest.a的静态链接库。</p>

<p>make之后运行的结果下图所示:
<img src="/images/unittest/1.png" alt="" /></p>

<ul>
  <li>例2 主要来讲述类中的成员函数如何进行单元测试，也包含3个文件，分别为sample2.h, sample2.cc , sample2_unittest.cc</li>
</ul>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cm">/*sample2.h*/</span>
<span class="cp">#ifndef GTEST_SAMPLES_SAMPLE2_H_
#define GTEST_SAMPLES_SAMPLE2_H_
</span>
<span class="cp">#include &lt;string.h&gt;
</span>

<span class="c1">// A simple string class.
// 简单的字符串类
</span><span class="k">class</span> <span class="nc">MyString</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c_string_</span><span class="p">;</span>
  <span class="c1">//复制操作符被禁用
</span>  <span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// Clones a 0-terminated C string, allocating memory using new.
</span>  <span class="c1">// 克隆一个以'\0'结尾的字符串，并分配内存
</span>  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">CloneCString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">a_c_string</span><span class="p">);</span>

  <span class="c1">////////////////////////////////////////////////////////////
</span>  <span class="c1">//
</span>  <span class="c1">// C'tors
</span>
  <span class="c1">// The default c'tor constructs a NULL string.
</span>  <span class="c1">// 默认构造函数
</span>  <span class="n">MyString</span><span class="p">()</span> <span class="o">:</span> <span class="n">c_string_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Constructs a MyString by cloning a 0-terminated C string.
</span>  <span class="c1">// 通过clone一个以‘\0’结尾的字符串来构建MyString
</span>  <span class="k">explicit</span> <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">a_c_string</span><span class="p">)</span> <span class="o">:</span> <span class="n">c_string_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Set</span><span class="p">(</span><span class="n">a_c_string</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Copy c'tor
</span>  <span class="c1">// 拷贝构造函数
</span>  <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">string</span><span class="p">)</span> <span class="o">:</span> <span class="n">c_string_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Set</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="n">c_string_</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">////////////////////////////////////////////////////////////
</span>  <span class="c1">//
</span>  <span class="c1">// D'tor.  MyString is intended to be a final class, so the d'tor
</span>  <span class="c1">// doesn't need to be virtual.
</span>  <span class="c1">//
</span>  <span class="c1">// 因为MyString作为最终类存在，所以析构函数不必为虚函数
</span>  <span class="o">~</span><span class="n">MyString</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">c_string_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Gets the 0-terminated C string this MyString object represents.
</span>  <span class="c1">// 获取c_string_
</span>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c_string</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c_string_</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">size_t</span> <span class="n">Length</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">c_string_</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">strlen</span><span class="p">(</span><span class="n">c_string_</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Sets the 0-terminated C string this MyString object represents.
</span>  <span class="c1">// 设置MyString的c_string_
</span>  <span class="kt">void</span> <span class="n">Set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c_string</span><span class="p">);</span>
<span class="p">};</span>
<span class="cp">#endif  // GTEST_SAMPLES_SAMPLE2_H_
</span>
<span class="cm">/*sample2.cc*/</span>
<span class="cp">#include "sample2.h"
</span>
<span class="cp">#include &lt;string.h&gt;
</span>
<span class="c1">// Clones a 0-terminated C string, allocating memory using new.
</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">MyString</span><span class="o">::</span><span class="n">CloneCString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">a_c_string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a_c_string</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">a_c_string</span><span class="p">);</span>
  <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">clone</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">];</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">clone</span><span class="p">,</span> <span class="n">a_c_string</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">clone</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Sets the 0-terminated C string this MyString object
// represents.
</span><span class="kt">void</span> <span class="n">MyString</span><span class="o">::</span><span class="n">Set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">a_c_string</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Makes sure this works when c_string == c_string_
</span>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">MyString</span><span class="o">::</span><span class="n">CloneCString</span><span class="p">(</span><span class="n">a_c_string</span><span class="p">);</span>
  <span class="k">delete</span><span class="p">[]</span> <span class="n">c_string_</span><span class="p">;</span>
  <span class="n">c_string_</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*sample2_unittest.cc*/</span>
<span class="c1">// This sample shows how to write a more complex unit test for a class
// that has multiple member functions.
//
// Usually, it's a good idea to have one test for each method in your
// class.  You don't have to do that exactly, but it helps to keep
// your tests organized.  You may also throw in additional tests as
// needed.
//
// 这个例子将展示如何为一个具有多个成员函数的类编写较为复杂的单元测试
//
// 通常为你类中的每一个方法都做一次测试是一个好主意。虽然你并非一定要
// 这么做，但是这样做将使你的测试集更便于管理，当然你也可以根据需要添
// 加额外的测试用例
</span>
<span class="cp">#include "sample2.h"
#include "gtest/gtest.h"
</span>
<span class="c1">// In this example, we test the MyString class (a simple string).
</span>
<span class="c1">// Tests the default c'tor.
</span><span class="n">TEST</span><span class="p">(</span><span class="n">MyString</span><span class="p">,</span> <span class="n">DefaultConstructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">MyString</span> <span class="n">s</span><span class="p">;</span>

  <span class="c1">// Asserts that s.c_string() returns NULL.
</span>  <span class="c1">//
</span>  <span class="c1">// &lt;TechnicalDetails&gt;
</span>  <span class="c1">//
</span>  <span class="c1">// If we write NULL instead of
</span>  <span class="c1">//
</span>  <span class="c1">//   static_cast&lt;const char *&gt;(NULL)
</span>  <span class="c1">//
</span>  <span class="c1">// in this assertion, it will generate a warning on gcc 3.4.  The
</span>  <span class="c1">// reason is that EXPECT_EQ needs to know the types of its
</span>  <span class="c1">// arguments in order to print them when it fails.  Since NULL is
</span>  <span class="c1">// #defined as 0, the compiler will use the formatter function for
</span>  <span class="c1">// int to print it.  However, gcc thinks that NULL should be used as
</span>  <span class="c1">// a pointer, not an int, and therefore complains.
</span>  <span class="c1">//
</span>  <span class="c1">// The root of the problem is C++'s lack of distinction between the
</span>  <span class="c1">// integer number 0 and the null pointer constant.  Unfortunately,
</span>  <span class="c1">// we have to live with this fact.
</span>  <span class="c1">//
</span>  <span class="c1">//技术细节：
</span>  <span class="c1">//   如果我们使用NULL，而不是static_cast&lt;const char *&gt;(NULL)。在断言中
</span>  <span class="c1">//如果编译器为gcc3.4,它将产生一个警告。产生警告的原因是，EXPECT_EQ需要
</span>  <span class="c1">//知道它参数的具体类型，以便产生错误的时候将其输出出来。由于NULL被
</span>  <span class="c1">//#define定义为0，所以编译器会使用格式化函数来将其输出。然而，GCC认为
</span>  <span class="c1">//NULL应该被当作指针类型，而不是int整形，所以编译器会抱怨。
</span>  <span class="c1">//
</span>  <span class="c1">//产生这个问题的根源是，C++对整数0以及空指针常量缺乏判别依据。不幸的是
</span>  <span class="c1">//我要学会接受这个现实。
</span>  <span class="c1">//
</span>  <span class="c1">// &lt;/TechnicalDetails&gt;
</span>  <span class="n">EXPECT_STREQ</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">c_string</span><span class="p">());</span>

  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0u</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">Length</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="n">kHelloString</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="p">;</span>

<span class="c1">// Tests the c'tor that accepts a C string.
// 测试构造函数
</span><span class="n">TEST</span><span class="p">(</span><span class="n">MyString</span><span class="p">,</span> <span class="n">ConstructorFromCString</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">MyString</span> <span class="n">s</span><span class="p">(</span><span class="n">kHelloString</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_string</span><span class="p">(),</span> <span class="n">kHelloString</span><span class="p">));</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kHelloString</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">kHelloString</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">s</span><span class="p">.</span><span class="n">Length</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// Tests the copy c'tor.
// 测试拷贝构造函数
</span><span class="n">TEST</span><span class="p">(</span><span class="n">MyString</span><span class="p">,</span> <span class="n">CopyConstructor</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">MyString</span> <span class="n">s1</span><span class="p">(</span><span class="n">kHelloString</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MyString</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>
  <span class="c1">//下面的判断会是失败的
</span>  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">s2</span><span class="p">.</span><span class="n">c_string</span><span class="p">(),</span> <span class="n">kHelloString</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Tests the Set method.
// 测试Set方法
</span><span class="n">TEST</span><span class="p">(</span><span class="n">MyString</span><span class="p">,</span> <span class="n">Set</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MyString</span> <span class="n">s</span><span class="p">;</span>

  <span class="n">s</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="n">kHelloString</span><span class="p">);</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_string</span><span class="p">(),</span> <span class="n">kHelloString</span><span class="p">));</span>

  <span class="c1">// Set should work when the input pointer is the same as the one
</span>  <span class="c1">// already in the MyString object.
</span>  <span class="c1">//
</span>  <span class="c1">// Set函数在输入指针与已存在于MyString对象中的指针相同时，下面的
</span>  <span class="c1">// 测试才会通过
</span>  <span class="n">s</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_string</span><span class="p">());</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_string</span><span class="p">(),</span> <span class="n">kHelloString</span><span class="p">));</span>

  <span class="c1">// Can we set the MyString to NULL?
</span>  <span class="n">s</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="n">EXPECT_STREQ</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">s</span><span class="p">.</span><span class="n">c_string</span><span class="p">());</span>
<span class="p">}</span></code></pre></figure>

<p>sample2的运行截图：
<img src="/images/unittest/2.png" alt="" /></p>

<p>例一阐述的是如果对普通的函数进行单元测试，而例二则阐述如何对类中的成员函数进行单元测试。大致的方法基本相同，只不过在测试类成员函数之前，要先定义类，也就是例子中的MyString s;上述两个例子是gtest的简单应用，当然对于类中成员函数的单元测试要复杂的多，比如成员函数的公有还是私有，成员函数的耦合性等等，这些会在最后的单元测试实践中讨论。好了，初步的介绍就到这吧~</p>


	  ]]></description>
	</item>


</channel>
</rss>
